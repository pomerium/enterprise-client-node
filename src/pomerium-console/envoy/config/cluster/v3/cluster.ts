// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies
// @generated from protobuf file "envoy/config/cluster/v3/cluster.proto" (package "envoy.config.cluster.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TcpKeepalive } from "../../core/v3/address";
import { DoubleValue } from "../../../../google/protobuf/wrappers";
import { HealthStatusSet } from "../../core/v3/health_check";
import { MetadataKey } from "../../../type/metadata/v3/metadata";
import { UInt64Value } from "../../../../google/protobuf/wrappers";
import { Percent } from "../../../type/v3/percent";
import { RuntimeDouble } from "../../core/v3/base";
import { Struct } from "../../../../google/protobuf/struct";
import { ConfigSource } from "../../core/v3/config_source";
import { Filter } from "./filter";
import { Metadata } from "../../core/v3/base";
import { TransportSocket } from "../../core/v3/base";
import { BindConfig } from "../../core/v3/address";
import { OutlierDetection } from "./outlier_detection";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { TypedExtensionConfig } from "../../core/v3/extension";
import { DnsResolutionConfig } from "../../core/v3/resolver";
import { Address } from "../../core/v3/address";
import { Any } from "../../../../google/protobuf/any";
import { Http2ProtocolOptions } from "../../core/v3/protocol";
import { Http1ProtocolOptions } from "../../core/v3/protocol";
import { HttpProtocolOptions } from "../../core/v3/protocol";
import { UpstreamHttpProtocolOptions } from "../../core/v3/protocol";
import { CircuitBreakers } from "./circuit_breaker";
import { HealthCheck } from "../../core/v3/health_check";
import { ClusterLoadAssignment } from "../../endpoint/v3/endpoint";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Duration } from "../../../../google/protobuf/duration";
import { CollectionEntry } from "../../../../xds/core/v3/collection_entry";
// [#protodoc-title: Cluster configuration]

/**
 * Cluster list collections. Entries are ``Cluster`` resources or references.
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.config.cluster.v3.ClusterCollection
 */
export interface ClusterCollection {
    /**
     * @generated from protobuf field: xds.core.v3.CollectionEntry entries = 1;
     */
    entries?: CollectionEntry;
}
/**
 * Configuration for a single upstream cluster.
 * [#next-free-field: 57]
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster
 */
export interface Cluster {
    /**
     * Configuration to use different transport sockets for different endpoints.
     * The entry of ``envoy.transport_socket_match`` in the
     * :ref:`LbEndpoint.Metadata <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`
     * is used to match against the transport sockets as they appear in the list. The first
     * :ref:`match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` is used.
     * For example, with the following match
     *
     * .. code-block:: yaml
     *
     *  transport_socket_matches:
     *  - name: "enableMTLS"
     *    match:
     *      acceptMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *  - name: "defaultToPlaintext"
     *    match: {}
     *    transport_socket:
     *      name: envoy.transport_sockets.raw_buffer
     *
     * Connections to the endpoints whose metadata value under ``envoy.transport_socket_match``
     * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
     *
     * If a :ref:`socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` with empty match
     * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
     * socket match in case above.
     *
     * If an endpoint metadata's value under ``envoy.transport_socket_match`` does not match any
     * ``TransportSocketMatch``, socket configuration fallbacks to use the ``tls_context`` or
     * ``transport_socket`` specified in this cluster.
     *
     * This field allows gradual and flexible transport socket configuration changes.
     *
     * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
     * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
     * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
     * has "acceptPlaintext": "true" metadata information.
     *
     * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
     * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
     * ``TransportSocketMatch`` in this field. Other client Envoys receive CDS without
     * ``transport_socket_match`` set, and still send plain text traffic to the same cluster.
     *
     * This field can be used to specify custom transport socket configurations for health
     * checks by adding matching key/value pairs in a health check's
     * :ref:`transport socket match criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>` field.
     *
     * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
     *
     * @generated from protobuf field: repeated envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;
     */
    transportSocketMatches: Cluster_TransportSocketMatch[];
    /**
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
     * <envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name>` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * An optional alternative to the cluster name to be used for observability. This name is used
     * emitting stats for the cluster and access logging the cluster name. This will appear as
     * additional information in configuration dumps of a cluster's current status as
     * :ref:`observability_name <envoy_v3_api_field_admin.v3.ClusterStatus.observability_name>`
     * and as an additional tag "upstream_cluster.name" while tracing. Note: Any ``:`` in the name
     * will be converted to ``_`` when emitting statistics. This should not be confused with
     * :ref:`Router Filter Header <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
     *
     * @generated from protobuf field: string alt_stat_name = 28;
     */
    altStatName: string;
    /**
     * @generated from protobuf oneof: cluster_discovery_type
     */
    clusterDiscoveryType: {
        oneofKind: "type";
        /**
         * The :ref:`service discovery type <arch_overview_service_discovery_types>`
         * to use for resolving the cluster.
         *
         * @generated from protobuf field: envoy.config.cluster.v3.Cluster.DiscoveryType type = 2;
         */
        type: Cluster_DiscoveryType;
    } | {
        oneofKind: "clusterType";
        /**
         * The custom cluster type.
         *
         * @generated from protobuf field: envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;
         */
        clusterType: Cluster_CustomClusterType;
    } | {
        oneofKind: undefined;
    };
    /**
     * Configuration to use for EDS updates for the Cluster.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;
     */
    edsClusterConfig?: Cluster_EdsClusterConfig;
    /**
     * The timeout for new network connections to hosts in the cluster.
     * If not set, a default value of 5s will be used.
     *
     * @generated from protobuf field: google.protobuf.Duration connect_timeout = 4;
     */
    connectTimeout?: Duration;
    /**
     * Soft limit on size of the cluster’s connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     *
     * @generated from protobuf field: google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;
     */
    perConnectionBufferLimitBytes?: UInt32Value;
    /**
     * The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
     * when picking a host in the cluster.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6;
     */
    lbPolicy: Cluster_LbPolicy;
    /**
     * Setting this is required for specifying members of
     * :ref:`STATIC<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC>`,
     * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
     * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
     * This field supersedes the ``hosts`` field in the v2 API.
     *
     * .. attention::
     *
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments<envoy_v3_api_msg_config.endpoint.v3.ClusterLoadAssignment>`.
     *
     *
     * @generated from protobuf field: envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;
     */
    loadAssignment?: ClusterLoadAssignment;
    /**
     * Optional :ref:`active health checking <arch_overview_health_checking>`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HealthCheck health_checks = 8;
     */
    healthChecks: HealthCheck[];
    /**
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     *
     * .. attention::
     *   This field has been deprecated in favor of the :ref:`max_requests_per_connection <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_requests_per_connection>` field.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.UInt32Value max_requests_per_connection = 9 [deprecated = true];
     */
    maxRequestsPerConnection?: UInt32Value;
    /**
     * Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;
     */
    circuitBreakers?: CircuitBreakers;
    /**
     * HTTP protocol options that are applied only to upstream HTTP connections.
     * These options apply to all HTTP versions.
     * This has been deprecated in favor of
     * :ref:`upstream_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
     * in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
     * upstream_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
     * See :ref:`upstream_http_protocol_options
     * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
     * for example usage.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];
     */
    upstreamHttpProtocolOptions?: UpstreamHttpProtocolOptions;
    /**
     * Additional options when handling HTTP requests upstream. These options will be applicable to
     * both HTTP1 and HTTP2 requests.
     * This has been deprecated in favor of
     * :ref:`common_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options>`
     * in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
     * common_http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
     * See :ref:`upstream_http_protocol_options
     * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
     * for example usage.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];
     */
    commonHttpProtocolOptions?: HttpProtocolOptions;
    /**
     * Additional options when handling HTTP1 requests.
     * This has been deprecated in favor of http_protocol_options fields in the
     * :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
     * See :ref:`upstream_http_protocol_options
     * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
     * for example usage.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];
     */
    httpProtocolOptions?: Http1ProtocolOptions;
    /**
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, ``http2_protocol_options`` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * This has been deprecated in favor of http2_protocol_options fields in the
     * :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>`
     * message. http2_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
     * See :ref:`upstream_http_protocol_options
     * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
     * for example usage.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true];
     */
    http2ProtocolOptions?: Http2ProtocolOptions;
    /**
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * [#next-major-version: make this a list of typed extensions.]
     *
     * @generated from protobuf field: map<string, google.protobuf.Any> typed_extension_protocol_options = 36;
     */
    typedExtensionProtocolOptions: {
        [key: string]: Any;
    };
    /**
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
     * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
     * this value is used as the cluster’s DNS refresh
     * rate. The value configured must be at least 1ms. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
     * and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
     * this setting is ignored.
     *
     * @generated from protobuf field: google.protobuf.Duration dns_refresh_rate = 16;
     */
    dnsRefreshRate?: Duration;
    /**
     * If the DNS failure refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
     * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
     * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
     * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
     * other than :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
     * :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
     * ignored.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44;
     */
    dnsFailureRefreshRate?: Cluster_RefreshRate;
    /**
     * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
     * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
     * resolution.
     *
     * @generated from protobuf field: bool respect_dns_ttl = 39;
     */
    respectDnsTtl: boolean;
    /**
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO>`.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17;
     */
    dnsLookupFamily: Cluster_DnsLookupFamily;
    /**
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
     * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
     * this value is used to specify the cluster’s dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
     * and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
     * this setting is ignored.
     * This field is deprecated in favor of ``dns_resolution_config``
     * which aggregates all of the DNS resolver configuration in a single message.
     *
     * @deprecated
     * @generated from protobuf field: repeated envoy.config.core.v3.Address dns_resolvers = 18 [deprecated = true];
     */
    dnsResolvers: Address[];
    /**
     * Always use TCP queries instead of UDP queries for DNS lookups.
     * This field is deprecated in favor of ``dns_resolution_config``
     * which aggregates all of the DNS resolver configuration in a single message.
     *
     * @deprecated
     * @generated from protobuf field: bool use_tcp_for_dns_lookups = 45 [deprecated = true];
     */
    useTcpForDnsLookups: boolean;
    /**
     * DNS resolution configuration which includes the underlying dns resolver addresses and options.
     * This field is deprecated in favor of
     * :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 53 [deprecated = true];
     */
    dnsResolutionConfig?: DnsResolutionConfig;
    /**
     * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
     * or any other DNS resolver types and the related parameters.
     * For example, an object of
     * :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
     * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
     * :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
     * configuration.
     * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
     * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
     * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
     * [#extension-category: envoy.network.dns_resolver]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 55;
     */
    typedDnsResolverConfig?: TypedExtensionConfig;
    /**
     * Optional configuration for having cluster readiness block on warm-up. Currently, only applicable for
     * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
     * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
     * or :ref:`Redis Cluster<arch_overview_redis>`.
     * If true, cluster readiness blocks on warm-up. If false, the cluster will complete
     * initialization whether or not warm-up has completed. Defaults to true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue wait_for_warm_on_init = 54;
     */
    waitForWarmOnInit?: BoolValue;
    /**
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;
     */
    outlierDetection?: OutlierDetection;
    /**
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`
     * this setting is ignored.
     *
     * @generated from protobuf field: google.protobuf.Duration cleanup_interval = 20;
     */
    cleanupInterval?: Duration;
    /**
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     *
     * @generated from protobuf field: envoy.config.core.v3.BindConfig upstream_bind_config = 21;
     */
    upstreamBindConfig?: BindConfig;
    /**
     * Configuration for load balancing subsetting.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;
     */
    lbSubsetConfig?: Cluster_LbSubsetConfig;
    /**
     * @generated from protobuf oneof: lb_config
     */
    lbConfig: {
        oneofKind: "ringHashLbConfig";
        /**
         * Optional configuration for the Ring Hash load balancing policy.
         *
         * @generated from protobuf field: envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;
         */
        ringHashLbConfig: Cluster_RingHashLbConfig;
    } | {
        oneofKind: "maglevLbConfig";
        /**
         * Optional configuration for the Maglev load balancing policy.
         *
         * @generated from protobuf field: envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;
         */
        maglevLbConfig: Cluster_MaglevLbConfig;
    } | {
        oneofKind: "originalDstLbConfig";
        /**
         * Optional configuration for the Original Destination load balancing policy.
         *
         * @generated from protobuf field: envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;
         */
        originalDstLbConfig: Cluster_OriginalDstLbConfig;
    } | {
        oneofKind: "leastRequestLbConfig";
        /**
         * Optional configuration for the LeastRequest load balancing policy.
         *
         * @generated from protobuf field: envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;
         */
        leastRequestLbConfig: Cluster_LeastRequestLbConfig;
    } | {
        oneofKind: "roundRobinLbConfig";
        /**
         * Optional configuration for the RoundRobin load balancing policy.
         *
         * @generated from protobuf field: envoy.config.cluster.v3.Cluster.RoundRobinLbConfig round_robin_lb_config = 56;
         */
        roundRobinLbConfig: Cluster_RoundRobinLbConfig;
    } | {
        oneofKind: undefined;
    };
    /**
     * Common configuration for all load balancer implementations.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;
     */
    commonLbConfig?: Cluster_CommonLbConfig;
    /**
     * Optional custom transport socket implementation to use for upstream connections.
     * To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and
     * :ref:`UpstreamTlsContexts <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>` in the ``typed_config``.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     *
     * @generated from protobuf field: envoy.config.core.v3.TransportSocket transport_socket = 24;
     */
    transportSocket?: TransportSocket;
    /**
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as ``envoy.filters.http.router``.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata = 25;
     */
    metadata?: Metadata;
    /**
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * This has been deprecated in favor of setting explicit protocol selection
     * in the :ref:`http_protocol_options
     * <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
     * http_protocol_options can be set via the cluster's
     * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];
     */
    protocolSelection: Cluster_ClusterProtocolSelection;
    /**
     * Optional options for upstream connections.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;
     */
    upstreamConnectionOptions?: UpstreamConnectionOptions;
    /**
     * If an upstream host becomes unhealthy (as determined by the configured health checks
     * or outlier detection), immediately close all connections to the failed host.
     *
     * .. note::
     *
     *   This is currently only supported for connections created by tcp_proxy.
     *
     * .. note::
     *
     *   The current implementation of this feature closes all connections immediately when
     *   the unhealthy status is detected. If there are a large number of connections open
     *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
     *   time exclusively closing these connections, and not processing any other traffic.
     *
     * @generated from protobuf field: bool close_connections_on_host_health_failure = 31;
     */
    closeConnectionsOnHostHealthFailure: boolean;
    /**
     * If set to true, Envoy will ignore the health value of a host when processing its removal
     * from service discovery. This means that if active health checking is used, Envoy will *not*
     * wait for the endpoint to go unhealthy before removing it.
     *
     * @generated from protobuf field: bool ignore_health_on_host_removal = 32;
     */
    ignoreHealthOnHostRemoval: boolean;
    /**
     * An (optional) network filter chain, listed in the order the filters should be applied.
     * The chain will be applied to all outgoing connections that Envoy makes to the upstream
     * servers of this cluster.
     *
     * @generated from protobuf field: repeated envoy.config.cluster.v3.Filter filters = 40;
     */
    filters: Filter[];
    /**
     * If this field is set and is supported by the client, it will supersede the value of
     * :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;
     */
    loadBalancingPolicy?: LoadBalancingPolicy;
    /**
     * [#not-implemented-hide:]
     * If present, tells the client where to send load reports via LRS. If not present, the
     * client will fall back to a client-side default, which may be either (a) don't send any
     * load reports or (b) send load reports for all clusters to a single default server
     * (which may be configured in the bootstrap file).
     *
     * Note that if multiple clusters point to the same LRS server, the client may choose to
     * create a separate stream for each cluster or it may choose to coalesce the data for
     * multiple clusters onto a single stream. Either way, the client must make sure to send
     * the data for any given cluster on no more than one stream.
     *
     * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
     * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
     * from the LRS stream here.]
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource lrs_server = 42;
     */
    lrsServer?: ConfigSource;
    /**
     * If track_timeout_budgets is true, the :ref:`timeout budget histograms
     * <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
     * request. These show what percentage of a request's per try and global timeout was used. A value
     * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
     * of 100 would indicate that the request took the entirety of the timeout given to it.
     *
     * .. attention::
     *
     *   This field has been deprecated in favor of ``timeout_budgets``, part of
     *   :ref:`track_cluster_stats <envoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats>`.
     *
     * @deprecated
     * @generated from protobuf field: bool track_timeout_budgets = 47 [deprecated = true];
     */
    trackTimeoutBudgets: boolean;
    /**
     * Optional customization and configuration of upstream connection pool, and upstream type.
     *
     * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
     * TCP upstreams.
     *
     * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
     * HTTP, using the http connection pool and the codec from ``http2_protocol_options``
     *
     * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
     * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
     *
     * The default pool used is the generic connection pool which creates the HTTP upstream for most
     * HTTP requests, and the TCP upstream if CONNECT termination is configured.
     *
     * If users desire custom connection pool or upstream behavior, for example terminating
     * CONNECT only if a custom filter indicates it is appropriate, the custom factories
     * can be registered and configured here.
     * [#extension-category: envoy.upstreams]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;
     */
    upstreamConfig?: TypedExtensionConfig;
    /**
     * Configuration to track optional cluster stats.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;
     */
    trackClusterStats?: TrackClusterStats;
    /**
     * Preconnect configuration for this cluster.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;
     */
    preconnectPolicy?: Cluster_PreconnectPolicy;
    /**
     * If ``connection_pool_per_downstream_connection`` is true, the cluster will use a separate
     * connection pool for every downstream connection
     *
     * @generated from protobuf field: bool connection_pool_per_downstream_connection = 51;
     */
    connectionPoolPerDownstreamConnection: boolean;
}
/**
 * TransportSocketMatch specifies what transport socket config will be used
 * when the match conditions are satisfied.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.TransportSocketMatch
 */
export interface Cluster_TransportSocketMatch {
    /**
     * The name of the match, used in stats generation.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Optional endpoint metadata match criteria.
     * The connection to the endpoint with metadata matching what is set in this field
     * will use the transport socket configuration specified here.
     * The endpoint's metadata entry in ``envoy.transport_socket_match`` is used to match
     * against the values specified in this field.
     *
     * @generated from protobuf field: google.protobuf.Struct match = 2;
     */
    match?: Struct;
    /**
     * The configuration of the transport socket.
     * [#extension-category: envoy.transport_sockets.upstream]
     *
     * @generated from protobuf field: envoy.config.core.v3.TransportSocket transport_socket = 3;
     */
    transportSocket?: TransportSocket;
}
/**
 * Extended cluster type.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.CustomClusterType
 */
export interface Cluster_CustomClusterType {
    /**
     * The type of the cluster to instantiate. The name must match a supported cluster type.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Cluster specific configuration which depends on the cluster being instantiated.
     * See the supported cluster for further documentation.
     * [#extension-category: envoy.clusters]
     *
     * @generated from protobuf field: google.protobuf.Any typed_config = 2;
     */
    typedConfig?: Any;
}
/**
 * Only valid when discovery type is EDS.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.EdsClusterConfig
 */
export interface Cluster_EdsClusterConfig {
    /**
     * Configuration for the source of EDS updates for this Cluster.
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource eds_config = 1;
     */
    edsConfig?: ConfigSource;
    /**
     * Optional alternative to cluster name to present to EDS. This does not
     * have the same restrictions as cluster name, i.e. it may be arbitrary
     * length. This may be a xdstp:// URL.
     *
     * @generated from protobuf field: string service_name = 2;
     */
    serviceName: string;
}
/**
 * Optionally divide the endpoints in this cluster into subsets defined by
 * endpoint metadata and selected by route and weighted cluster metadata.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.LbSubsetConfig
 */
export interface Cluster_LbSubsetConfig {
    /**
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1;
     */
    fallbackPolicy: Cluster_LbSubsetConfig_LbSubsetFallbackPolicy;
    /**
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the ``envoy.lb``
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
     *
     * @generated from protobuf field: google.protobuf.Struct default_subset = 2;
     */
    defaultSubset?: Struct;
    /**
     * For each entry, LbEndpoint.Metadata's
     * ``envoy.lb`` namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     *
     * .. code-block:: json
     *
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     *
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     *
     * @generated from protobuf field: repeated envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;
     */
    subsetSelectors: Cluster_LbSubsetConfig_LbSubsetSelector[];
    /**
     * If true, routing to subsets will take into account the localities and locality weights of the
     * endpoints when making the routing decision.
     *
     * There are some potential pitfalls associated with enabling this feature, as the resulting
     * traffic split after applying both a subset match and locality weights might be undesirable.
     *
     * Consider for example a situation in which you have 50/50 split across two localities X/Y
     * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
     * host selected but Y having 100, then a lot more load is being dumped on the single host in X
     * than originally anticipated in the load balancing assignment delivered via EDS.
     *
     * @generated from protobuf field: bool locality_weight_aware = 4;
     */
    localityWeightAware: boolean;
    /**
     * When used with locality_weight_aware, scales the weight of each locality by the ratio
     * of hosts in the subset vs hosts in the original subset. This aims to even out the load
     * going to an individual locality if said locality is disproportionately affected by the
     * subset predicate.
     *
     * @generated from protobuf field: bool scale_locality_weight = 5;
     */
    scaleLocalityWeight: boolean;
    /**
     * If true, when a fallback policy is configured and its corresponding subset fails to find
     * a host this will cause any host to be selected instead.
     *
     * This is useful when using the default subset as the fallback policy, given the default
     * subset might become empty. With this option enabled, if that happens the LB will attempt
     * to select a host from the entire cluster.
     *
     * @generated from protobuf field: bool panic_mode_any = 6;
     */
    panicModeAny: boolean;
    /**
     * If true, metadata specified for a metadata key will be matched against the corresponding
     * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
     * and any of the elements in the list matches the criteria.
     *
     * @generated from protobuf field: bool list_as_any = 7;
     */
    listAsAny: boolean;
    /**
     * Fallback mechanism that allows to try different route metadata until a host is found.
     * If load balancing process, including all its mechanisms (like
     * :ref:`fallback_policy<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.fallback_policy>`)
     * fails to select a host, this policy decides if and how the process is repeated using another metadata.
     *
     * The value defaults to
     * :ref:`METADATA_NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK>`.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy metadata_fallback_policy = 8;
     */
    metadataFallbackPolicy: Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy;
}
/**
 * Specifications for subsets.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector
 */
export interface Cluster_LbSubsetConfig_LbSubsetSelector {
    /**
     * List of keys to match with the weighted cluster metadata.
     *
     * @generated from protobuf field: repeated string keys = 1;
     */
    keys: string[];
    /**
     * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
     * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
     *
     * If a match is found to a host, that host will be used regardless of priority levels.
     *
     * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in ``keys``
     * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
     * :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
     * present in the current configuration.
     *
     * @generated from protobuf field: bool single_host_per_subset = 4;
     */
    singleHostPerSubset: boolean;
    /**
     * The behavior used when no endpoint subset matches the selected route's
     * metadata.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2;
     */
    fallbackPolicy: Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy;
    /**
     * Subset of
     * :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
     * :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
     * fallback policy.
     * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
     * For any other fallback policy the parameter is not used and should not be set.
     * Only values also present in
     * :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
     * ``fallback_keys_subset`` cannot be equal to ``keys``.
     *
     * @generated from protobuf field: repeated string fallback_keys_subset = 3;
     */
    fallbackKeysSubset: string[];
}
/**
 * Allows to override top level fallback policy per selector.
 *
 * @generated from protobuf enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy
 */
export enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
    /**
     * If NOT_DEFINED top level config fallback policy is used instead.
     *
     * @generated from protobuf enum value: NOT_DEFINED = 0;
     */
    NOT_DEFINED = 0,
    /**
     * If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
     *
     * @generated from protobuf enum value: NO_FALLBACK = 1;
     */
    NO_FALLBACK = 1,
    /**
     * If ANY_ENDPOINT is selected, any cluster endpoint may be returned
     * (subject to policy, health checks, etc).
     *
     * @generated from protobuf enum value: ANY_ENDPOINT = 2;
     */
    ANY_ENDPOINT = 2,
    /**
     * If DEFAULT_SUBSET is selected, load balancing is performed over the
     * endpoints matching the values from the default_subset field.
     *
     * @generated from protobuf enum value: DEFAULT_SUBSET = 3;
     */
    DEFAULT_SUBSET = 3,
    /**
     * If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
     * keys reduced to
     * :ref:`fallback_keys_subset<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
     * It allows for a fallback to a different, less specific selector if some of the keys of
     * the selector are considered optional.
     *
     * @generated from protobuf enum value: KEYS_SUBSET = 4;
     */
    KEYS_SUBSET = 4
}
/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 *
 * @generated from protobuf enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy
 */
export enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
    /**
     * @generated from protobuf enum value: NO_FALLBACK = 0;
     */
    NO_FALLBACK = 0,
    /**
     * @generated from protobuf enum value: ANY_ENDPOINT = 1;
     */
    ANY_ENDPOINT = 1,
    /**
     * @generated from protobuf enum value: DEFAULT_SUBSET = 2;
     */
    DEFAULT_SUBSET = 2
}
/**
 * @generated from protobuf enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy
 */
export enum Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy {
    /**
     * No fallback. Route metadata will be used as-is.
     *
     * @generated from protobuf enum value: METADATA_NO_FALLBACK = 0;
     */
    METADATA_NO_FALLBACK = 0,
    /**
     * A special metadata key ``fallback_list`` will be used to provide variants of metadata to try.
     * Value of ``fallback_list`` key has to be a list. Every list element has to be a struct - it will
     * be merged with route metadata, overriding keys that appear in both places.
     * ``fallback_list`` entries will be used in order until a host is found.
     *
     * ``fallback_list`` key itself is removed from metadata before subset load balancing is performed.
     *
     * Example:
     *
     * for metadata:
     *
     * .. code-block:: yaml
     *
     *   version: 1.0
     *   fallback_list:
     *     - version: 2.0
     *       hardware: c64
     *     - hardware: c32
     *     - version: 3.0
     *
     * at first, metadata:
     *
     * .. code-block:: json
     *
     *   {"version": "2.0", "hardware": "c64"}
     *
     * will be used for load balancing. If no host is found, metadata:
     *
     * .. code-block:: json
     *
     *   {"version": "1.0", "hardware": "c32"}
     *
     * is next to try. If it still results in no host, finally metadata:
     *
     * .. code-block:: json
     *
     *   {"version": "3.0"}
     *
     * is used.
     *
     * @generated from protobuf enum value: FALLBACK_LIST = 1;
     */
    FALLBACK_LIST = 1
}
/**
 * Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.SlowStartConfig
 */
export interface Cluster_SlowStartConfig {
    /**
     * Represents the size of slow start window.
     * If set, the newly created host remains in slow start mode starting from its creation time
     * for the duration of slow start window.
     *
     * @generated from protobuf field: google.protobuf.Duration slow_start_window = 1;
     */
    slowStartWindow?: Duration;
    /**
     * This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
     * so that endpoint would get linearly increasing amount of traffic.
     * When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
     * The value of aggression parameter should be greater than 0.0.
     * By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
     *
     * During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
     * ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``,
     * where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``.
     *
     * As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
     * Once host exits slow start, time_factor and aggression no longer affect its weight.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeDouble aggression = 2;
     */
    aggression?: RuntimeDouble;
    /**
     * Configures the minimum percentage of origin weight that avoids too small new weight,
     * which may cause endpoints in slow start mode receive no traffic in slow start window.
     * If not specified, the default is 10%.
     *
     * @generated from protobuf field: envoy.type.v3.Percent min_weight_percent = 3;
     */
    minWeightPercent?: Percent;
}
/**
 * Specific configuration for the RoundRobin load balancing policy.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.RoundRobinLbConfig
 */
export interface Cluster_RoundRobinLbConfig {
    /**
     * Configuration for slow start mode.
     * If this configuration is not set, slow start will not be not enabled.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.SlowStartConfig slow_start_config = 1;
     */
    slowStartConfig?: Cluster_SlowStartConfig;
}
/**
 * Specific configuration for the LeastRequest load balancing policy.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.LeastRequestLbConfig
 */
export interface Cluster_LeastRequestLbConfig {
    /**
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value choice_count = 1;
     */
    choiceCount?: UInt32Value;
    /**
     * The following formula is used to calculate the dynamic weights when hosts have different load
     * balancing weights:
     *
     * ``weight = load_balancing_weight / (active_requests + 1)^active_request_bias``
     *
     * The larger the active request bias is, the more aggressively active requests will lower the
     * effective weight when all host weights are not equal.
     *
     * ``active_request_bias`` must be greater than or equal to 0.0.
     *
     * When ``active_request_bias == 0.0`` the Least Request Load Balancer doesn't consider the number
     * of active requests at the time it picks a host and behaves like the Round Robin Load
     * Balancer.
     *
     * When ``active_request_bias > 0.0`` the Least Request Load Balancer scales the load balancing
     * weight by the number of active requests at the time it does a pick.
     *
     * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
     * host sets changes, e.g., whenever there is a host membership update or a host load balancing
     * weight change.
     *
     * .. note::
     *   This setting only takes effect if all host weights are not equal.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeDouble active_request_bias = 2;
     */
    activeRequestBias?: RuntimeDouble;
    /**
     * Configuration for slow start mode.
     * If this configuration is not set, slow start will not be not enabled.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.SlowStartConfig slow_start_config = 3;
     */
    slowStartConfig?: Cluster_SlowStartConfig;
}
/**
 * Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
 * load balancing policy.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.RingHashLbConfig
 */
export interface Cluster_RingHashLbConfig {
    /**
     * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
     * provided host) the better the request distribution will reflect the desired weights. Defaults
     * to 1024 entries, and limited to 8M entries. See also
     * :ref:`maximum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value minimum_ring_size = 1;
     */
    minimumRingSize?: UInt64Value;
    /**
     * The hash function used to hash hosts onto the ketama ring. The value defaults to
     * :ref:`XX_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3;
     */
    hashFunction: Cluster_RingHashLbConfig_HashFunction;
    /**
     * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
     * to further constrain resource use. See also
     * :ref:`minimum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value maximum_ring_size = 4;
     */
    maximumRingSize?: UInt64Value;
}
/**
 * The hash function used to hash hosts onto the ketama ring.
 *
 * @generated from protobuf enum envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction
 */
export enum Cluster_RingHashLbConfig_HashFunction {
    /**
     * Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
     *
     * @generated from protobuf enum value: XX_HASH = 0;
     */
    XX_HASH = 0,
    /**
     * Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
     * std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
     * on Linux and not macOS.
     *
     * @generated from protobuf enum value: MURMUR_HASH_2 = 1;
     */
    MURMUR_HASH_2 = 1
}
/**
 * Specific configuration for the :ref:`Maglev<arch_overview_load_balancing_types_maglev>`
 * load balancing policy.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.MaglevLbConfig
 */
export interface Cluster_MaglevLbConfig {
    /**
     * The table size for Maglev hashing. Maglev aims for "minimal disruption" rather than an absolute guarantee.
     * Minimal disruption means that when the set of upstream hosts change, a connection will likely be sent to the same
     * upstream as it was before. Increasing the table size reduces the amount of disruption.
     * The table size must be prime number limited to 5000011. If it is not specified, the default is 65537.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value table_size = 1;
     */
    tableSize?: UInt64Value;
}
/**
 * Specific configuration for the
 * :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
 * load balancing policy.
 * [#extension: envoy.clusters.original_dst]
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.OriginalDstLbConfig
 */
export interface Cluster_OriginalDstLbConfig {
    /**
     * When true, a HTTP header can be used to override the original dst address. The default header is
     * :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>`.
     *
     * .. attention::
     *
     *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
     *   route traffic to arbitrary hosts and/or ports, which may have serious security
     *   consequences.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     *
     * @generated from protobuf field: bool use_http_header = 1;
     */
    useHttpHeader: boolean;
    /**
     * The http header to override destination address if :ref:`use_http_header <envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.use_http_header>`.
     * is set to true. If the value is empty, :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>` will be used.
     *
     * @generated from protobuf field: string http_header_name = 2;
     */
    httpHeaderName: string;
    /**
     * The port to override for the original dst address. This port
     * will take precedence over filter state and header override ports
     *
     * @generated from protobuf field: google.protobuf.UInt32Value upstream_port_override = 3;
     */
    upstreamPortOverride?: UInt32Value;
    /**
     * The dynamic metadata key to override destination address.
     * First the request metadata is considered, then the connection one.
     *
     * @generated from protobuf field: envoy.type.metadata.v3.MetadataKey metadata_key = 4;
     */
    metadataKey?: MetadataKey;
}
/**
 * Common configuration for all load balancer implementations.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.CommonLbConfig
 */
export interface Cluster_CommonLbConfig {
    /**
     * Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
     * If not specified, the default is 50%.
     * To disable panic mode, set to 0%.
     *
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     *
     * @generated from protobuf field: envoy.type.v3.Percent healthy_panic_threshold = 1;
     */
    healthyPanicThreshold?: Percent;
    /**
     * @generated from protobuf oneof: locality_config_specifier
     */
    localityConfigSpecifier: {
        oneofKind: "zoneAwareLbConfig";
        /**
         * @generated from protobuf field: envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;
         */
        zoneAwareLbConfig: Cluster_CommonLbConfig_ZoneAwareLbConfig;
    } | {
        oneofKind: "localityWeightedLbConfig";
        /**
         * @generated from protobuf field: envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;
         */
        localityWeightedLbConfig: Cluster_CommonLbConfig_LocalityWeightedLbConfig;
    } | {
        oneofKind: undefined;
    };
    /**
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster). Please always keep in mind that the use of sandbox technologies may change this
     * behavior.
     *
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     *
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     *
     * @generated from protobuf field: google.protobuf.Duration update_merge_window = 4;
     */
    updateMergeWindow?: Duration;
    /**
     * If set to true, Envoy will :ref:`exclude <arch_overview_load_balancing_excluded>` new hosts
     * when computing load balancing weights until they have been health checked for the first time.
     * This will have no effect unless active health checking is also configured.
     *
     * @generated from protobuf field: bool ignore_new_hosts_until_first_hc = 5;
     */
    ignoreNewHostsUntilFirstHc: boolean;
    /**
     * If set to ``true``, the cluster manager will drain all existing
     * connections to upstream hosts whenever hosts are added or removed from the cluster.
     *
     * @generated from protobuf field: bool close_connections_on_host_set_change = 6;
     */
    closeConnectionsOnHostSetChange: boolean;
    /**
     * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
     *
     * @generated from protobuf field: envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;
     */
    consistentHashingLbConfig?: Cluster_CommonLbConfig_ConsistentHashingLbConfig;
    /**
     * This controls what hosts are considered valid when using
     * :ref:`host overrides <arch_overview_load_balancing_override_host>`, which is used by some
     * filters to modify the load balancing decision.
     *
     * If this is unset then [UNKNOWN, HEALTHY, DEGRADED] will be applied by default. If this is
     * set with an empty set of statuses then host overrides will be ignored by the load balancing.
     *
     * @generated from protobuf field: envoy.config.core.v3.HealthStatusSet override_host_status = 8;
     */
    overrideHostStatus?: HealthStatusSet;
}
/**
 * Configuration for :ref:`zone aware routing
 * <arch_overview_load_balancing_zone_aware_routing>`.
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig
 */
export interface Cluster_CommonLbConfig_ZoneAwareLbConfig {
    /**
     * Configures percentage of requests that will be considered for zone aware routing
     * if zone aware routing is configured. If not specified, the default is 100%.
     * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
     * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
     *
     * @generated from protobuf field: envoy.type.v3.Percent routing_enabled = 1;
     */
    routingEnabled?: Percent;
    /**
     * Configures minimum upstream cluster size required for zone aware routing
     * If upstream cluster size is less than specified, zone aware routing is not performed
     * even if zone aware routing is configured. If not specified, the default is 6.
     * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
     * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value min_cluster_size = 2;
     */
    minClusterSize?: UInt64Value;
    /**
     * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
     * mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
     * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
     * failing service.
     *
     * @generated from protobuf field: bool fail_traffic_on_panic = 3;
     */
    failTrafficOnPanic: boolean;
}
/**
 * Configuration for :ref:`locality weighted load balancing
 * <arch_overview_load_balancing_locality_weighted_lb>`
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig
 */
export interface Cluster_CommonLbConfig_LocalityWeightedLbConfig {
}
/**
 * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
 *
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig
 */
export interface Cluster_CommonLbConfig_ConsistentHashingLbConfig {
    /**
     * If set to ``true``, the cluster will use hostname instead of the resolved
     * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
     *
     * @generated from protobuf field: bool use_hostname_for_hashing = 1;
     */
    useHostnameForHashing: boolean;
    /**
     * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
     * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
     * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
     * Minimum is 100.
     *
     * Applies to both Ring Hash and Maglev load balancers.
     *
     * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
     * ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
     * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
     * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
     * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
     * cascading overflow effect when choosing the next host in the ring/table).
     *
     * If weights are specified on the hosts, they are respected.
     *
     * This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
     * being probed, so use a higher value if you require better performance.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value hash_balance_factor = 2;
     */
    hashBalanceFactor?: UInt32Value;
}
/**
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.RefreshRate
 */
export interface Cluster_RefreshRate {
    /**
     * Specifies the base interval between refreshes. This parameter is required and must be greater
     * than zero and less than
     * :ref:`max_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval>`.
     *
     * @generated from protobuf field: google.protobuf.Duration base_interval = 1;
     */
    baseInterval?: Duration;
    /**
     * Specifies the maximum interval between refreshes. This parameter is optional, but must be
     * greater than or equal to the
     * :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`  if set. The default
     * is 10 times the :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`.
     *
     * @generated from protobuf field: google.protobuf.Duration max_interval = 2;
     */
    maxInterval?: Duration;
}
/**
 * @generated from protobuf message envoy.config.cluster.v3.Cluster.PreconnectPolicy
 */
export interface Cluster_PreconnectPolicy {
    /**
     * Indicates how many streams (rounded up) can be anticipated per-upstream for each
     * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
     * will only be done if the upstream is healthy and the cluster has traffic.
     *
     * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
     * established, one for the new incoming stream, and one for a presumed follow-up stream. For
     * HTTP/2, only one connection would be established by default as one connection can
     * serve both the original and presumed follow-up stream.
     *
     * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
     * active streams, there would be 100 connections in use, and 50 connections preconnected.
     * This might be a useful value for something like short lived single-use connections,
     * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
     * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
     * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
     * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
     * in case of unexpected disconnects where the connection could not be reused.
     *
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight. This means in steady state if a connection is torn down,
     * a subsequent streams will pay an upstream-rtt latency penalty waiting for a new connection.
     *
     * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
     * harm latency more than the preconnecting helps.
     *
     * @generated from protobuf field: google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1;
     */
    perUpstreamPreconnectRatio?: DoubleValue;
    /**
     * Indicates how many streams (rounded up) can be anticipated across a cluster for each
     * stream, useful for low QPS services. This is currently supported for a subset of
     * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
     * Unlike ``per_upstream_preconnect_ratio`` this preconnects across the upstream instances in a
     * cluster, doing best effort predictions of what upstream would be picked next and
     * pre-establishing a connection.
     *
     * Preconnecting will be limited to one preconnect per configured upstream in the cluster and will
     * only be done if there are healthy upstreams and the cluster has traffic.
     *
     * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
     * incoming stream, 2 connections will be preconnected - one to the first upstream for this
     * cluster, one to the second on the assumption there will be a follow-up stream.
     *
     * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
     * as needed to serve streams in flight, so during warm up and in steady state if a connection
     * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
     * connection establishment.
     *
     * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
     * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each
     * upstream.
     *
     * @generated from protobuf field: google.protobuf.DoubleValue predictive_preconnect_ratio = 2;
     */
    predictivePreconnectRatio?: DoubleValue;
}
/**
 * Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
 * for an explanation on each type.
 *
 * @generated from protobuf enum envoy.config.cluster.v3.Cluster.DiscoveryType
 */
export enum Cluster_DiscoveryType {
    /**
     * Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
     * for an explanation.
     *
     * @generated from protobuf enum value: STATIC = 0;
     */
    STATIC = 0,
    /**
     * Refer to the :ref:`strict DNS discovery
     * type<arch_overview_service_discovery_types_strict_dns>`
     * for an explanation.
     *
     * @generated from protobuf enum value: STRICT_DNS = 1;
     */
    STRICT_DNS = 1,
    /**
     * Refer to the :ref:`logical DNS discovery
     * type<arch_overview_service_discovery_types_logical_dns>`
     * for an explanation.
     *
     * @generated from protobuf enum value: LOGICAL_DNS = 2;
     */
    LOGICAL_DNS = 2,
    /**
     * Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
     * for an explanation.
     *
     * @generated from protobuf enum value: EDS = 3;
     */
    EDS = 3,
    /**
     * Refer to the :ref:`original destination discovery
     * type<arch_overview_service_discovery_types_original_destination>`
     * for an explanation.
     *
     * @generated from protobuf enum value: ORIGINAL_DST = 4;
     */
    ORIGINAL_DST = 4
}
/**
 * Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
 * overview section for information on each type.
 *
 * @generated from protobuf enum envoy.config.cluster.v3.Cluster.LbPolicy
 */
export enum Cluster_LbPolicy {
    /**
     * Refer to the :ref:`round robin load balancing
     * policy<arch_overview_load_balancing_types_round_robin>`
     * for an explanation.
     *
     * @generated from protobuf enum value: ROUND_ROBIN = 0;
     */
    ROUND_ROBIN = 0,
    /**
     * Refer to the :ref:`least request load balancing
     * policy<arch_overview_load_balancing_types_least_request>`
     * for an explanation.
     *
     * @generated from protobuf enum value: LEAST_REQUEST = 1;
     */
    LEAST_REQUEST = 1,
    /**
     * Refer to the :ref:`ring hash load balancing
     * policy<arch_overview_load_balancing_types_ring_hash>`
     * for an explanation.
     *
     * @generated from protobuf enum value: RING_HASH = 2;
     */
    RING_HASH = 2,
    /**
     * Refer to the :ref:`random load balancing
     * policy<arch_overview_load_balancing_types_random>`
     * for an explanation.
     *
     * @generated from protobuf enum value: RANDOM = 3;
     */
    RANDOM = 3,
    /**
     * Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
     * for an explanation.
     *
     * @generated from protobuf enum value: MAGLEV = 5;
     */
    MAGLEV = 5,
    /**
     * This load balancer type must be specified if the configured cluster provides a cluster
     * specific load balancer. Consult the configured cluster's documentation for whether to set
     * this option or not.
     *
     * @generated from protobuf enum value: CLUSTER_PROVIDED = 6;
     */
    CLUSTER_PROVIDED = 6,
    /**
     * Use the new :ref:`load_balancing_policy
     * <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field to determine the LB policy.
     * This has been deprecated in favor of using the :ref:`load_balancing_policy
     * <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field without
     * setting any value in :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
     *
     * @generated from protobuf enum value: LOAD_BALANCING_POLICY_CONFIG = 7;
     */
    LOAD_BALANCING_POLICY_CONFIG = 7
}
/**
 * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
 * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
 * only perform a lookup for addresses in the IPv6 family. If AUTO is
 * specified, the DNS resolver will first perform a lookup for addresses in
 * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
 * This is semantically equivalent to a non-existent V6_PREFERRED option.
 * AUTO is a legacy name that is more opaque than
 * necessary and will be deprecated in favor of V6_PREFERRED in a future major version of the API.
 * If V4_PREFERRED is specified, the DNS resolver will first perform a lookup for addresses in the
 * IPv4 family and fallback to a lookup for addresses in the IPv6 family. i.e., the callback
 * target will only get v6 addresses if there were NO v4 addresses to return.
 * If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families,
 * and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for
 * upstream connections. Refer to :ref:`Happy Eyeballs Support <arch_overview_happy_eyeballs>`
 * for more information.
 * For cluster types other than
 * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
 * :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
 * this setting is
 * ignored.
 * [#next-major-version: deprecate AUTO in favor of a V6_PREFERRED option.]
 *
 * @generated from protobuf enum envoy.config.cluster.v3.Cluster.DnsLookupFamily
 */
export enum Cluster_DnsLookupFamily {
    /**
     * @generated from protobuf enum value: AUTO = 0;
     */
    AUTO = 0,
    /**
     * @generated from protobuf enum value: V4_ONLY = 1;
     */
    V4_ONLY = 1,
    /**
     * @generated from protobuf enum value: V6_ONLY = 2;
     */
    V6_ONLY = 2,
    /**
     * @generated from protobuf enum value: V4_PREFERRED = 3;
     */
    V4_PREFERRED = 3,
    /**
     * @generated from protobuf enum value: ALL = 4;
     */
    ALL = 4
}
/**
 * @generated from protobuf enum envoy.config.cluster.v3.Cluster.ClusterProtocolSelection
 */
export enum Cluster_ClusterProtocolSelection {
    /**
     * Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
     * If :ref:`http2_protocol_options <envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
     * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
     *
     * @generated from protobuf enum value: USE_CONFIGURED_PROTOCOL = 0;
     */
    USE_CONFIGURED_PROTOCOL = 0,
    /**
     * Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
     *
     * @generated from protobuf enum value: USE_DOWNSTREAM_PROTOCOL = 1;
     */
    USE_DOWNSTREAM_PROTOCOL = 1
}
/**
 * Extensible load balancing policy configuration.
 *
 * Every LB policy defined via this mechanism will be identified via a unique name using reverse
 * DNS notation. If the policy needs configuration parameters, it must define a message for its
 * own configuration, which will be stored in the config field. The name of the policy will tell
 * clients which type of message they should expect to see in the config field.
 *
 * Note that there are cases where it is useful to be able to independently select LB policies
 * for choosing a locality and for choosing an endpoint within that locality. For example, a
 * given deployment may always use the same policy to choose the locality, but for choosing the
 * endpoint within the locality, some clusters may use weighted-round-robin, while others may
 * use some sort of session-based balancing.
 *
 * This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
 * child LB policy for each locality. For each request, the parent chooses the locality and then
 * delegates to the child policy for that locality to choose the endpoint within the locality.
 *
 * To facilitate this, the config message for the top-level LB policy may include a field of
 * type LoadBalancingPolicy that specifies the child policy.
 *
 * @generated from protobuf message envoy.config.cluster.v3.LoadBalancingPolicy
 */
export interface LoadBalancingPolicy {
    /**
     * Each client will iterate over the list in order and stop at the first policy that it
     * supports. This provides a mechanism for starting to use new LB policies that are not yet
     * supported by all clients.
     *
     * @generated from protobuf field: repeated envoy.config.cluster.v3.LoadBalancingPolicy.Policy policies = 1;
     */
    policies: LoadBalancingPolicy_Policy[];
}
/**
 * @generated from protobuf message envoy.config.cluster.v3.LoadBalancingPolicy.Policy
 */
export interface LoadBalancingPolicy_Policy {
    /**
     * [#extension-category: envoy.load_balancing_policies]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig typed_extension_config = 4;
     */
    typedExtensionConfig?: TypedExtensionConfig;
}
/**
 * @generated from protobuf message envoy.config.cluster.v3.UpstreamConnectionOptions
 */
export interface UpstreamConnectionOptions {
    /**
     * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
     *
     * @generated from protobuf field: envoy.config.core.v3.TcpKeepalive tcp_keepalive = 1;
     */
    tcpKeepalive?: TcpKeepalive;
    /**
     * If enabled, associates the interface name of the local address with the upstream connection.
     * This can be used by extensions during processing of requests. The association mechanism is
     * implementation specific. Defaults to false due to performance concerns.
     *
     * @generated from protobuf field: bool set_local_interface_name_on_upstream_connections = 2;
     */
    setLocalInterfaceNameOnUpstreamConnections: boolean;
}
/**
 * @generated from protobuf message envoy.config.cluster.v3.TrackClusterStats
 */
export interface TrackClusterStats {
    /**
     * If timeout_budgets is true, the :ref:`timeout budget histograms
     * <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
     * request. These show what percentage of a request's per try and global timeout was used. A value
     * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
     * of 100 would indicate that the request took the entirety of the timeout given to it.
     *
     * @generated from protobuf field: bool timeout_budgets = 1;
     */
    timeoutBudgets: boolean;
    /**
     * If request_response_sizes is true, then the :ref:`histograms
     * <config_cluster_manager_cluster_stats_request_response_sizes>`  tracking header and body sizes
     * of requests and responses will be published.
     *
     * @generated from protobuf field: bool request_response_sizes = 2;
     */
    requestResponseSizes: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class ClusterCollection$Type extends MessageType<ClusterCollection> {
    constructor() {
        super("envoy.config.cluster.v3.ClusterCollection", [
            { no: 1, name: "entries", kind: "message", T: () => CollectionEntry }
        ]);
    }
    create(value?: PartialMessage<ClusterCollection>): ClusterCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClusterCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterCollection): ClusterCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xds.core.v3.CollectionEntry entries */ 1:
                    message.entries = CollectionEntry.internalBinaryRead(reader, reader.uint32(), options, message.entries);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xds.core.v3.CollectionEntry entries = 1; */
        if (message.entries)
            CollectionEntry.internalBinaryWrite(message.entries, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.ClusterCollection
 */
export const ClusterCollection = new ClusterCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster$Type extends MessageType<Cluster> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster", [
            { no: 43, name: "transport_socket_matches", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Cluster_TransportSocketMatch },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 28, name: "alt_stat_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "udpa.annotations.field_migrate": { rename: "observability_name" } } },
            { no: 2, name: "type", kind: "enum", oneof: "clusterDiscoveryType", T: () => ["envoy.config.cluster.v3.Cluster.DiscoveryType", Cluster_DiscoveryType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 38, name: "cluster_type", kind: "message", oneof: "clusterDiscoveryType", T: () => Cluster_CustomClusterType },
            { no: 3, name: "eds_cluster_config", kind: "message", T: () => Cluster_EdsClusterConfig },
            { no: 4, name: "connect_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 5, name: "per_connection_buffer_limit_bytes", kind: "message", T: () => UInt32Value, options: { "udpa.annotations.security": { configureForUntrustedUpstream: true } } },
            { no: 6, name: "lb_policy", kind: "enum", T: () => ["envoy.config.cluster.v3.Cluster.LbPolicy", Cluster_LbPolicy], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 33, name: "load_assignment", kind: "message", T: () => ClusterLoadAssignment },
            { no: 8, name: "health_checks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HealthCheck },
            { no: 9, name: "max_requests_per_connection", kind: "message", T: () => UInt32Value, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 10, name: "circuit_breakers", kind: "message", T: () => CircuitBreakers },
            { no: 46, name: "upstream_http_protocol_options", kind: "message", T: () => UpstreamHttpProtocolOptions, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 29, name: "common_http_protocol_options", kind: "message", T: () => HttpProtocolOptions, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 13, name: "http_protocol_options", kind: "message", T: () => Http1ProtocolOptions, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 14, name: "http2_protocol_options", kind: "message", T: () => Http2ProtocolOptions, options: { "envoy.annotations.deprecated_at_minor_version": "3.0", "udpa.annotations.security": { configureForUntrustedUpstream: true } } },
            { no: 36, name: "typed_extension_protocol_options", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } },
            { no: 16, name: "dns_refresh_rate", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: { nanos: 1000000 } } } } },
            { no: 44, name: "dns_failure_refresh_rate", kind: "message", T: () => Cluster_RefreshRate },
            { no: 39, name: "respect_dns_ttl", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "dns_lookup_family", kind: "enum", T: () => ["envoy.config.cluster.v3.Cluster.DnsLookupFamily", Cluster_DnsLookupFamily], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 18, name: "dns_resolvers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Address, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 45, name: "use_tcp_for_dns_lookups", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 53, name: "dns_resolution_config", kind: "message", T: () => DnsResolutionConfig, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 55, name: "typed_dns_resolver_config", kind: "message", T: () => TypedExtensionConfig },
            { no: 54, name: "wait_for_warm_on_init", kind: "message", T: () => BoolValue },
            { no: 19, name: "outlier_detection", kind: "message", T: () => OutlierDetection },
            { no: 20, name: "cleanup_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 21, name: "upstream_bind_config", kind: "message", T: () => BindConfig },
            { no: 22, name: "lb_subset_config", kind: "message", T: () => Cluster_LbSubsetConfig },
            { no: 23, name: "ring_hash_lb_config", kind: "message", oneof: "lbConfig", T: () => Cluster_RingHashLbConfig },
            { no: 52, name: "maglev_lb_config", kind: "message", oneof: "lbConfig", T: () => Cluster_MaglevLbConfig },
            { no: 34, name: "original_dst_lb_config", kind: "message", oneof: "lbConfig", T: () => Cluster_OriginalDstLbConfig },
            { no: 37, name: "least_request_lb_config", kind: "message", oneof: "lbConfig", T: () => Cluster_LeastRequestLbConfig },
            { no: 56, name: "round_robin_lb_config", kind: "message", oneof: "lbConfig", T: () => Cluster_RoundRobinLbConfig },
            { no: 27, name: "common_lb_config", kind: "message", T: () => Cluster_CommonLbConfig },
            { no: 24, name: "transport_socket", kind: "message", T: () => TransportSocket },
            { no: 25, name: "metadata", kind: "message", T: () => Metadata },
            { no: 26, name: "protocol_selection", kind: "enum", T: () => ["envoy.config.cluster.v3.Cluster.ClusterProtocolSelection", Cluster_ClusterProtocolSelection], options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 30, name: "upstream_connection_options", kind: "message", T: () => UpstreamConnectionOptions },
            { no: 31, name: "close_connections_on_host_health_failure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 32, name: "ignore_health_on_host_removal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 40, name: "filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Filter },
            { no: 41, name: "load_balancing_policy", kind: "message", T: () => LoadBalancingPolicy },
            { no: 42, name: "lrs_server", kind: "message", T: () => ConfigSource },
            { no: 47, name: "track_timeout_budgets", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 48, name: "upstream_config", kind: "message", T: () => TypedExtensionConfig },
            { no: 49, name: "track_cluster_stats", kind: "message", T: () => TrackClusterStats },
            { no: 50, name: "preconnect_policy", kind: "message", T: () => Cluster_PreconnectPolicy },
            { no: 51, name: "connection_pool_per_downstream_connection", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster" } });
    }
    create(value?: PartialMessage<Cluster>): Cluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transportSocketMatches = [];
        message.name = "";
        message.altStatName = "";
        message.clusterDiscoveryType = { oneofKind: undefined };
        message.lbPolicy = 0;
        message.healthChecks = [];
        message.typedExtensionProtocolOptions = {};
        message.respectDnsTtl = false;
        message.dnsLookupFamily = 0;
        message.dnsResolvers = [];
        message.useTcpForDnsLookups = false;
        message.lbConfig = { oneofKind: undefined };
        message.protocolSelection = 0;
        message.closeConnectionsOnHostHealthFailure = false;
        message.ignoreHealthOnHostRemoval = false;
        message.filters = [];
        message.trackTimeoutBudgets = false;
        message.connectionPoolPerDownstreamConnection = false;
        if (value !== undefined)
            reflectionMergePartial<Cluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster): Cluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches */ 43:
                    message.transportSocketMatches.push(Cluster_TransportSocketMatch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string alt_stat_name */ 28:
                    message.altStatName = reader.string();
                    break;
                case /* envoy.config.cluster.v3.Cluster.DiscoveryType type */ 2:
                    message.clusterDiscoveryType = {
                        oneofKind: "type",
                        type: reader.int32()
                    };
                    break;
                case /* envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type */ 38:
                    message.clusterDiscoveryType = {
                        oneofKind: "clusterType",
                        clusterType: Cluster_CustomClusterType.internalBinaryRead(reader, reader.uint32(), options, (message.clusterDiscoveryType as any).clusterType)
                    };
                    break;
                case /* envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config */ 3:
                    message.edsClusterConfig = Cluster_EdsClusterConfig.internalBinaryRead(reader, reader.uint32(), options, message.edsClusterConfig);
                    break;
                case /* google.protobuf.Duration connect_timeout */ 4:
                    message.connectTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.connectTimeout);
                    break;
                case /* google.protobuf.UInt32Value per_connection_buffer_limit_bytes */ 5:
                    message.perConnectionBufferLimitBytes = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.perConnectionBufferLimitBytes);
                    break;
                case /* envoy.config.cluster.v3.Cluster.LbPolicy lb_policy */ 6:
                    message.lbPolicy = reader.int32();
                    break;
                case /* envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment */ 33:
                    message.loadAssignment = ClusterLoadAssignment.internalBinaryRead(reader, reader.uint32(), options, message.loadAssignment);
                    break;
                case /* repeated envoy.config.core.v3.HealthCheck health_checks */ 8:
                    message.healthChecks.push(HealthCheck.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.UInt32Value max_requests_per_connection = 9 [deprecated = true];*/ 9:
                    message.maxRequestsPerConnection = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxRequestsPerConnection);
                    break;
                case /* envoy.config.cluster.v3.CircuitBreakers circuit_breakers */ 10:
                    message.circuitBreakers = CircuitBreakers.internalBinaryRead(reader, reader.uint32(), options, message.circuitBreakers);
                    break;
                case /* envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];*/ 46:
                    message.upstreamHttpProtocolOptions = UpstreamHttpProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.upstreamHttpProtocolOptions);
                    break;
                case /* envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];*/ 29:
                    message.commonHttpProtocolOptions = HttpProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.commonHttpProtocolOptions);
                    break;
                case /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];*/ 13:
                    message.httpProtocolOptions = Http1ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.httpProtocolOptions);
                    break;
                case /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true];*/ 14:
                    message.http2ProtocolOptions = Http2ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.http2ProtocolOptions);
                    break;
                case /* map<string, google.protobuf.Any> typed_extension_protocol_options */ 36:
                    this.binaryReadMap36(message.typedExtensionProtocolOptions, reader, options);
                    break;
                case /* google.protobuf.Duration dns_refresh_rate */ 16:
                    message.dnsRefreshRate = Duration.internalBinaryRead(reader, reader.uint32(), options, message.dnsRefreshRate);
                    break;
                case /* envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate */ 44:
                    message.dnsFailureRefreshRate = Cluster_RefreshRate.internalBinaryRead(reader, reader.uint32(), options, message.dnsFailureRefreshRate);
                    break;
                case /* bool respect_dns_ttl */ 39:
                    message.respectDnsTtl = reader.bool();
                    break;
                case /* envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family */ 17:
                    message.dnsLookupFamily = reader.int32();
                    break;
                case /* repeated envoy.config.core.v3.Address dns_resolvers = 18 [deprecated = true];*/ 18:
                    message.dnsResolvers.push(Address.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool use_tcp_for_dns_lookups = 45 [deprecated = true];*/ 45:
                    message.useTcpForDnsLookups = reader.bool();
                    break;
                case /* envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 53 [deprecated = true];*/ 53:
                    message.dnsResolutionConfig = DnsResolutionConfig.internalBinaryRead(reader, reader.uint32(), options, message.dnsResolutionConfig);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config */ 55:
                    message.typedDnsResolverConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.typedDnsResolverConfig);
                    break;
                case /* google.protobuf.BoolValue wait_for_warm_on_init */ 54:
                    message.waitForWarmOnInit = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.waitForWarmOnInit);
                    break;
                case /* envoy.config.cluster.v3.OutlierDetection outlier_detection */ 19:
                    message.outlierDetection = OutlierDetection.internalBinaryRead(reader, reader.uint32(), options, message.outlierDetection);
                    break;
                case /* google.protobuf.Duration cleanup_interval */ 20:
                    message.cleanupInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.cleanupInterval);
                    break;
                case /* envoy.config.core.v3.BindConfig upstream_bind_config */ 21:
                    message.upstreamBindConfig = BindConfig.internalBinaryRead(reader, reader.uint32(), options, message.upstreamBindConfig);
                    break;
                case /* envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config */ 22:
                    message.lbSubsetConfig = Cluster_LbSubsetConfig.internalBinaryRead(reader, reader.uint32(), options, message.lbSubsetConfig);
                    break;
                case /* envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config */ 23:
                    message.lbConfig = {
                        oneofKind: "ringHashLbConfig",
                        ringHashLbConfig: Cluster_RingHashLbConfig.internalBinaryRead(reader, reader.uint32(), options, (message.lbConfig as any).ringHashLbConfig)
                    };
                    break;
                case /* envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config */ 52:
                    message.lbConfig = {
                        oneofKind: "maglevLbConfig",
                        maglevLbConfig: Cluster_MaglevLbConfig.internalBinaryRead(reader, reader.uint32(), options, (message.lbConfig as any).maglevLbConfig)
                    };
                    break;
                case /* envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config */ 34:
                    message.lbConfig = {
                        oneofKind: "originalDstLbConfig",
                        originalDstLbConfig: Cluster_OriginalDstLbConfig.internalBinaryRead(reader, reader.uint32(), options, (message.lbConfig as any).originalDstLbConfig)
                    };
                    break;
                case /* envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config */ 37:
                    message.lbConfig = {
                        oneofKind: "leastRequestLbConfig",
                        leastRequestLbConfig: Cluster_LeastRequestLbConfig.internalBinaryRead(reader, reader.uint32(), options, (message.lbConfig as any).leastRequestLbConfig)
                    };
                    break;
                case /* envoy.config.cluster.v3.Cluster.RoundRobinLbConfig round_robin_lb_config */ 56:
                    message.lbConfig = {
                        oneofKind: "roundRobinLbConfig",
                        roundRobinLbConfig: Cluster_RoundRobinLbConfig.internalBinaryRead(reader, reader.uint32(), options, (message.lbConfig as any).roundRobinLbConfig)
                    };
                    break;
                case /* envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config */ 27:
                    message.commonLbConfig = Cluster_CommonLbConfig.internalBinaryRead(reader, reader.uint32(), options, message.commonLbConfig);
                    break;
                case /* envoy.config.core.v3.TransportSocket transport_socket */ 24:
                    message.transportSocket = TransportSocket.internalBinaryRead(reader, reader.uint32(), options, message.transportSocket);
                    break;
                case /* envoy.config.core.v3.Metadata metadata */ 25:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];*/ 26:
                    message.protocolSelection = reader.int32();
                    break;
                case /* envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options */ 30:
                    message.upstreamConnectionOptions = UpstreamConnectionOptions.internalBinaryRead(reader, reader.uint32(), options, message.upstreamConnectionOptions);
                    break;
                case /* bool close_connections_on_host_health_failure */ 31:
                    message.closeConnectionsOnHostHealthFailure = reader.bool();
                    break;
                case /* bool ignore_health_on_host_removal */ 32:
                    message.ignoreHealthOnHostRemoval = reader.bool();
                    break;
                case /* repeated envoy.config.cluster.v3.Filter filters */ 40:
                    message.filters.push(Filter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy */ 41:
                    message.loadBalancingPolicy = LoadBalancingPolicy.internalBinaryRead(reader, reader.uint32(), options, message.loadBalancingPolicy);
                    break;
                case /* envoy.config.core.v3.ConfigSource lrs_server */ 42:
                    message.lrsServer = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.lrsServer);
                    break;
                case /* bool track_timeout_budgets = 47 [deprecated = true];*/ 47:
                    message.trackTimeoutBudgets = reader.bool();
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig upstream_config */ 48:
                    message.upstreamConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.upstreamConfig);
                    break;
                case /* envoy.config.cluster.v3.TrackClusterStats track_cluster_stats */ 49:
                    message.trackClusterStats = TrackClusterStats.internalBinaryRead(reader, reader.uint32(), options, message.trackClusterStats);
                    break;
                case /* envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy */ 50:
                    message.preconnectPolicy = Cluster_PreconnectPolicy.internalBinaryRead(reader, reader.uint32(), options, message.preconnectPolicy);
                    break;
                case /* bool connection_pool_per_downstream_connection */ 51:
                    message.connectionPoolPerDownstreamConnection = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap36(map: Cluster["typedExtensionProtocolOptions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Cluster["typedExtensionProtocolOptions"] | undefined, val: Cluster["typedExtensionProtocolOptions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.cluster.v3.Cluster.typed_extension_protocol_options");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: Cluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43; */
        for (let i = 0; i < message.transportSocketMatches.length; i++)
            Cluster_TransportSocketMatch.internalBinaryWrite(message.transportSocketMatches[i], writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string alt_stat_name = 28; */
        if (message.altStatName !== "")
            writer.tag(28, WireType.LengthDelimited).string(message.altStatName);
        /* envoy.config.cluster.v3.Cluster.DiscoveryType type = 2; */
        if (message.clusterDiscoveryType.oneofKind === "type")
            writer.tag(2, WireType.Varint).int32(message.clusterDiscoveryType.type);
        /* envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38; */
        if (message.clusterDiscoveryType.oneofKind === "clusterType")
            Cluster_CustomClusterType.internalBinaryWrite(message.clusterDiscoveryType.clusterType, writer.tag(38, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3; */
        if (message.edsClusterConfig)
            Cluster_EdsClusterConfig.internalBinaryWrite(message.edsClusterConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration connect_timeout = 4; */
        if (message.connectTimeout)
            Duration.internalBinaryWrite(message.connectTimeout, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5; */
        if (message.perConnectionBufferLimitBytes)
            UInt32Value.internalBinaryWrite(message.perConnectionBufferLimitBytes, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6; */
        if (message.lbPolicy !== 0)
            writer.tag(6, WireType.Varint).int32(message.lbPolicy);
        /* envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33; */
        if (message.loadAssignment)
            ClusterLoadAssignment.internalBinaryWrite(message.loadAssignment, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HealthCheck health_checks = 8; */
        for (let i = 0; i < message.healthChecks.length; i++)
            HealthCheck.internalBinaryWrite(message.healthChecks[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_requests_per_connection = 9 [deprecated = true]; */
        if (message.maxRequestsPerConnection)
            UInt32Value.internalBinaryWrite(message.maxRequestsPerConnection, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10; */
        if (message.circuitBreakers)
            CircuitBreakers.internalBinaryWrite(message.circuitBreakers, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true]; */
        if (message.upstreamHttpProtocolOptions)
            UpstreamHttpProtocolOptions.internalBinaryWrite(message.upstreamHttpProtocolOptions, writer.tag(46, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true]; */
        if (message.commonHttpProtocolOptions)
            HttpProtocolOptions.internalBinaryWrite(message.commonHttpProtocolOptions, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true]; */
        if (message.httpProtocolOptions)
            Http1ProtocolOptions.internalBinaryWrite(message.httpProtocolOptions, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true]; */
        if (message.http2ProtocolOptions)
            Http2ProtocolOptions.internalBinaryWrite(message.http2ProtocolOptions, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Any> typed_extension_protocol_options = 36; */
        for (let k of globalThis.Object.keys(message.typedExtensionProtocolOptions)) {
            writer.tag(36, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.typedExtensionProtocolOptions[k], writer, options);
            writer.join().join();
        }
        /* google.protobuf.Duration dns_refresh_rate = 16; */
        if (message.dnsRefreshRate)
            Duration.internalBinaryWrite(message.dnsRefreshRate, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44; */
        if (message.dnsFailureRefreshRate)
            Cluster_RefreshRate.internalBinaryWrite(message.dnsFailureRefreshRate, writer.tag(44, WireType.LengthDelimited).fork(), options).join();
        /* bool respect_dns_ttl = 39; */
        if (message.respectDnsTtl !== false)
            writer.tag(39, WireType.Varint).bool(message.respectDnsTtl);
        /* envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17; */
        if (message.dnsLookupFamily !== 0)
            writer.tag(17, WireType.Varint).int32(message.dnsLookupFamily);
        /* repeated envoy.config.core.v3.Address dns_resolvers = 18 [deprecated = true]; */
        for (let i = 0; i < message.dnsResolvers.length; i++)
            Address.internalBinaryWrite(message.dnsResolvers[i], writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* bool use_tcp_for_dns_lookups = 45 [deprecated = true]; */
        if (message.useTcpForDnsLookups !== false)
            writer.tag(45, WireType.Varint).bool(message.useTcpForDnsLookups);
        /* envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 53 [deprecated = true]; */
        if (message.dnsResolutionConfig)
            DnsResolutionConfig.internalBinaryWrite(message.dnsResolutionConfig, writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 55; */
        if (message.typedDnsResolverConfig)
            TypedExtensionConfig.internalBinaryWrite(message.typedDnsResolverConfig, writer.tag(55, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue wait_for_warm_on_init = 54; */
        if (message.waitForWarmOnInit)
            BoolValue.internalBinaryWrite(message.waitForWarmOnInit, writer.tag(54, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.OutlierDetection outlier_detection = 19; */
        if (message.outlierDetection)
            OutlierDetection.internalBinaryWrite(message.outlierDetection, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration cleanup_interval = 20; */
        if (message.cleanupInterval)
            Duration.internalBinaryWrite(message.cleanupInterval, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.BindConfig upstream_bind_config = 21; */
        if (message.upstreamBindConfig)
            BindConfig.internalBinaryWrite(message.upstreamBindConfig, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22; */
        if (message.lbSubsetConfig)
            Cluster_LbSubsetConfig.internalBinaryWrite(message.lbSubsetConfig, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23; */
        if (message.lbConfig.oneofKind === "ringHashLbConfig")
            Cluster_RingHashLbConfig.internalBinaryWrite(message.lbConfig.ringHashLbConfig, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52; */
        if (message.lbConfig.oneofKind === "maglevLbConfig")
            Cluster_MaglevLbConfig.internalBinaryWrite(message.lbConfig.maglevLbConfig, writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34; */
        if (message.lbConfig.oneofKind === "originalDstLbConfig")
            Cluster_OriginalDstLbConfig.internalBinaryWrite(message.lbConfig.originalDstLbConfig, writer.tag(34, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37; */
        if (message.lbConfig.oneofKind === "leastRequestLbConfig")
            Cluster_LeastRequestLbConfig.internalBinaryWrite(message.lbConfig.leastRequestLbConfig, writer.tag(37, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.RoundRobinLbConfig round_robin_lb_config = 56; */
        if (message.lbConfig.oneofKind === "roundRobinLbConfig")
            Cluster_RoundRobinLbConfig.internalBinaryWrite(message.lbConfig.roundRobinLbConfig, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27; */
        if (message.commonLbConfig)
            Cluster_CommonLbConfig.internalBinaryWrite(message.commonLbConfig, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TransportSocket transport_socket = 24; */
        if (message.transportSocket)
            TransportSocket.internalBinaryWrite(message.transportSocket, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Metadata metadata = 25; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true]; */
        if (message.protocolSelection !== 0)
            writer.tag(26, WireType.Varint).int32(message.protocolSelection);
        /* envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30; */
        if (message.upstreamConnectionOptions)
            UpstreamConnectionOptions.internalBinaryWrite(message.upstreamConnectionOptions, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* bool close_connections_on_host_health_failure = 31; */
        if (message.closeConnectionsOnHostHealthFailure !== false)
            writer.tag(31, WireType.Varint).bool(message.closeConnectionsOnHostHealthFailure);
        /* bool ignore_health_on_host_removal = 32; */
        if (message.ignoreHealthOnHostRemoval !== false)
            writer.tag(32, WireType.Varint).bool(message.ignoreHealthOnHostRemoval);
        /* repeated envoy.config.cluster.v3.Filter filters = 40; */
        for (let i = 0; i < message.filters.length; i++)
            Filter.internalBinaryWrite(message.filters[i], writer.tag(40, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41; */
        if (message.loadBalancingPolicy)
            LoadBalancingPolicy.internalBinaryWrite(message.loadBalancingPolicy, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ConfigSource lrs_server = 42; */
        if (message.lrsServer)
            ConfigSource.internalBinaryWrite(message.lrsServer, writer.tag(42, WireType.LengthDelimited).fork(), options).join();
        /* bool track_timeout_budgets = 47 [deprecated = true]; */
        if (message.trackTimeoutBudgets !== false)
            writer.tag(47, WireType.Varint).bool(message.trackTimeoutBudgets);
        /* envoy.config.core.v3.TypedExtensionConfig upstream_config = 48; */
        if (message.upstreamConfig)
            TypedExtensionConfig.internalBinaryWrite(message.upstreamConfig, writer.tag(48, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49; */
        if (message.trackClusterStats)
            TrackClusterStats.internalBinaryWrite(message.trackClusterStats, writer.tag(49, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50; */
        if (message.preconnectPolicy)
            Cluster_PreconnectPolicy.internalBinaryWrite(message.preconnectPolicy, writer.tag(50, WireType.LengthDelimited).fork(), options).join();
        /* bool connection_pool_per_downstream_connection = 51; */
        if (message.connectionPoolPerDownstreamConnection !== false)
            writer.tag(51, WireType.Varint).bool(message.connectionPoolPerDownstreamConnection);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster
 */
export const Cluster = new Cluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_TransportSocketMatch$Type extends MessageType<Cluster_TransportSocketMatch> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.TransportSocketMatch", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "match", kind: "message", T: () => Struct },
            { no: 3, name: "transport_socket", kind: "message", T: () => TransportSocket }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.TransportSocketMatch" } });
    }
    create(value?: PartialMessage<Cluster_TransportSocketMatch>): Cluster_TransportSocketMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Cluster_TransportSocketMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_TransportSocketMatch): Cluster_TransportSocketMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct match */ 2:
                    message.match = Struct.internalBinaryRead(reader, reader.uint32(), options, message.match);
                    break;
                case /* envoy.config.core.v3.TransportSocket transport_socket */ 3:
                    message.transportSocket = TransportSocket.internalBinaryRead(reader, reader.uint32(), options, message.transportSocket);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_TransportSocketMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct match = 2; */
        if (message.match)
            Struct.internalBinaryWrite(message.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TransportSocket transport_socket = 3; */
        if (message.transportSocket)
            TransportSocket.internalBinaryWrite(message.transportSocket, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.TransportSocketMatch
 */
export const Cluster_TransportSocketMatch = new Cluster_TransportSocketMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_CustomClusterType$Type extends MessageType<Cluster_CustomClusterType> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.CustomClusterType", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "typed_config", kind: "message", T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.CustomClusterType" } });
    }
    create(value?: PartialMessage<Cluster_CustomClusterType>): Cluster_CustomClusterType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Cluster_CustomClusterType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_CustomClusterType): Cluster_CustomClusterType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 2:
                    message.typedConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.typedConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_CustomClusterType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 2; */
        if (message.typedConfig)
            Any.internalBinaryWrite(message.typedConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.CustomClusterType
 */
export const Cluster_CustomClusterType = new Cluster_CustomClusterType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_EdsClusterConfig$Type extends MessageType<Cluster_EdsClusterConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.EdsClusterConfig", [
            { no: 1, name: "eds_config", kind: "message", T: () => ConfigSource },
            { no: 2, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.EdsClusterConfig" } });
    }
    create(value?: PartialMessage<Cluster_EdsClusterConfig>): Cluster_EdsClusterConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceName = "";
        if (value !== undefined)
            reflectionMergePartial<Cluster_EdsClusterConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_EdsClusterConfig): Cluster_EdsClusterConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ConfigSource eds_config */ 1:
                    message.edsConfig = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.edsConfig);
                    break;
                case /* string service_name */ 2:
                    message.serviceName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_EdsClusterConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ConfigSource eds_config = 1; */
        if (message.edsConfig)
            ConfigSource.internalBinaryWrite(message.edsConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string service_name = 2; */
        if (message.serviceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.EdsClusterConfig
 */
export const Cluster_EdsClusterConfig = new Cluster_EdsClusterConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_LbSubsetConfig$Type extends MessageType<Cluster_LbSubsetConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.LbSubsetConfig", [
            { no: 1, name: "fallback_policy", kind: "enum", T: () => ["envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy", Cluster_LbSubsetConfig_LbSubsetFallbackPolicy], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "default_subset", kind: "message", T: () => Struct },
            { no: 3, name: "subset_selectors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Cluster_LbSubsetConfig_LbSubsetSelector },
            { no: 4, name: "locality_weight_aware", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "scale_locality_weight", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "panic_mode_any", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "list_as_any", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "metadata_fallback_policy", kind: "enum", T: () => ["envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy", Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.LbSubsetConfig" } });
    }
    create(value?: PartialMessage<Cluster_LbSubsetConfig>): Cluster_LbSubsetConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fallbackPolicy = 0;
        message.subsetSelectors = [];
        message.localityWeightAware = false;
        message.scaleLocalityWeight = false;
        message.panicModeAny = false;
        message.listAsAny = false;
        message.metadataFallbackPolicy = 0;
        if (value !== undefined)
            reflectionMergePartial<Cluster_LbSubsetConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_LbSubsetConfig): Cluster_LbSubsetConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy */ 1:
                    message.fallbackPolicy = reader.int32();
                    break;
                case /* google.protobuf.Struct default_subset */ 2:
                    message.defaultSubset = Struct.internalBinaryRead(reader, reader.uint32(), options, message.defaultSubset);
                    break;
                case /* repeated envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors */ 3:
                    message.subsetSelectors.push(Cluster_LbSubsetConfig_LbSubsetSelector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool locality_weight_aware */ 4:
                    message.localityWeightAware = reader.bool();
                    break;
                case /* bool scale_locality_weight */ 5:
                    message.scaleLocalityWeight = reader.bool();
                    break;
                case /* bool panic_mode_any */ 6:
                    message.panicModeAny = reader.bool();
                    break;
                case /* bool list_as_any */ 7:
                    message.listAsAny = reader.bool();
                    break;
                case /* envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy metadata_fallback_policy */ 8:
                    message.metadataFallbackPolicy = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_LbSubsetConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1; */
        if (message.fallbackPolicy !== 0)
            writer.tag(1, WireType.Varint).int32(message.fallbackPolicy);
        /* google.protobuf.Struct default_subset = 2; */
        if (message.defaultSubset)
            Struct.internalBinaryWrite(message.defaultSubset, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3; */
        for (let i = 0; i < message.subsetSelectors.length; i++)
            Cluster_LbSubsetConfig_LbSubsetSelector.internalBinaryWrite(message.subsetSelectors[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool locality_weight_aware = 4; */
        if (message.localityWeightAware !== false)
            writer.tag(4, WireType.Varint).bool(message.localityWeightAware);
        /* bool scale_locality_weight = 5; */
        if (message.scaleLocalityWeight !== false)
            writer.tag(5, WireType.Varint).bool(message.scaleLocalityWeight);
        /* bool panic_mode_any = 6; */
        if (message.panicModeAny !== false)
            writer.tag(6, WireType.Varint).bool(message.panicModeAny);
        /* bool list_as_any = 7; */
        if (message.listAsAny !== false)
            writer.tag(7, WireType.Varint).bool(message.listAsAny);
        /* envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy metadata_fallback_policy = 8; */
        if (message.metadataFallbackPolicy !== 0)
            writer.tag(8, WireType.Varint).int32(message.metadataFallbackPolicy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.LbSubsetConfig
 */
export const Cluster_LbSubsetConfig = new Cluster_LbSubsetConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_LbSubsetConfig_LbSubsetSelector$Type extends MessageType<Cluster_LbSubsetConfig_LbSubsetSelector> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector", [
            { no: 1, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "single_host_per_subset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "fallback_policy", kind: "enum", T: () => ["envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy", Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 3, name: "fallback_keys_subset", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector" } });
    }
    create(value?: PartialMessage<Cluster_LbSubsetConfig_LbSubsetSelector>): Cluster_LbSubsetConfig_LbSubsetSelector {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        message.singleHostPerSubset = false;
        message.fallbackPolicy = 0;
        message.fallbackKeysSubset = [];
        if (value !== undefined)
            reflectionMergePartial<Cluster_LbSubsetConfig_LbSubsetSelector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_LbSubsetConfig_LbSubsetSelector): Cluster_LbSubsetConfig_LbSubsetSelector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string keys */ 1:
                    message.keys.push(reader.string());
                    break;
                case /* bool single_host_per_subset */ 4:
                    message.singleHostPerSubset = reader.bool();
                    break;
                case /* envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy */ 2:
                    message.fallbackPolicy = reader.int32();
                    break;
                case /* repeated string fallback_keys_subset */ 3:
                    message.fallbackKeysSubset.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_LbSubsetConfig_LbSubsetSelector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.keys[i]);
        /* bool single_host_per_subset = 4; */
        if (message.singleHostPerSubset !== false)
            writer.tag(4, WireType.Varint).bool(message.singleHostPerSubset);
        /* envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2; */
        if (message.fallbackPolicy !== 0)
            writer.tag(2, WireType.Varint).int32(message.fallbackPolicy);
        /* repeated string fallback_keys_subset = 3; */
        for (let i = 0; i < message.fallbackKeysSubset.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.fallbackKeysSubset[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector
 */
export const Cluster_LbSubsetConfig_LbSubsetSelector = new Cluster_LbSubsetConfig_LbSubsetSelector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_SlowStartConfig$Type extends MessageType<Cluster_SlowStartConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.SlowStartConfig", [
            { no: 1, name: "slow_start_window", kind: "message", T: () => Duration },
            { no: 2, name: "aggression", kind: "message", T: () => RuntimeDouble },
            { no: 3, name: "min_weight_percent", kind: "message", T: () => Percent }
        ]);
    }
    create(value?: PartialMessage<Cluster_SlowStartConfig>): Cluster_SlowStartConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cluster_SlowStartConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_SlowStartConfig): Cluster_SlowStartConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration slow_start_window */ 1:
                    message.slowStartWindow = Duration.internalBinaryRead(reader, reader.uint32(), options, message.slowStartWindow);
                    break;
                case /* envoy.config.core.v3.RuntimeDouble aggression */ 2:
                    message.aggression = RuntimeDouble.internalBinaryRead(reader, reader.uint32(), options, message.aggression);
                    break;
                case /* envoy.type.v3.Percent min_weight_percent */ 3:
                    message.minWeightPercent = Percent.internalBinaryRead(reader, reader.uint32(), options, message.minWeightPercent);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_SlowStartConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration slow_start_window = 1; */
        if (message.slowStartWindow)
            Duration.internalBinaryWrite(message.slowStartWindow, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeDouble aggression = 2; */
        if (message.aggression)
            RuntimeDouble.internalBinaryWrite(message.aggression, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Percent min_weight_percent = 3; */
        if (message.minWeightPercent)
            Percent.internalBinaryWrite(message.minWeightPercent, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.SlowStartConfig
 */
export const Cluster_SlowStartConfig = new Cluster_SlowStartConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_RoundRobinLbConfig$Type extends MessageType<Cluster_RoundRobinLbConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.RoundRobinLbConfig", [
            { no: 1, name: "slow_start_config", kind: "message", T: () => Cluster_SlowStartConfig }
        ]);
    }
    create(value?: PartialMessage<Cluster_RoundRobinLbConfig>): Cluster_RoundRobinLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cluster_RoundRobinLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_RoundRobinLbConfig): Cluster_RoundRobinLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.cluster.v3.Cluster.SlowStartConfig slow_start_config */ 1:
                    message.slowStartConfig = Cluster_SlowStartConfig.internalBinaryRead(reader, reader.uint32(), options, message.slowStartConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_RoundRobinLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.cluster.v3.Cluster.SlowStartConfig slow_start_config = 1; */
        if (message.slowStartConfig)
            Cluster_SlowStartConfig.internalBinaryWrite(message.slowStartConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.RoundRobinLbConfig
 */
export const Cluster_RoundRobinLbConfig = new Cluster_RoundRobinLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_LeastRequestLbConfig$Type extends MessageType<Cluster_LeastRequestLbConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.LeastRequestLbConfig", [
            { no: 1, name: "choice_count", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 2 } } } },
            { no: 2, name: "active_request_bias", kind: "message", T: () => RuntimeDouble },
            { no: 3, name: "slow_start_config", kind: "message", T: () => Cluster_SlowStartConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.LeastRequestLbConfig" } });
    }
    create(value?: PartialMessage<Cluster_LeastRequestLbConfig>): Cluster_LeastRequestLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cluster_LeastRequestLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_LeastRequestLbConfig): Cluster_LeastRequestLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value choice_count */ 1:
                    message.choiceCount = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.choiceCount);
                    break;
                case /* envoy.config.core.v3.RuntimeDouble active_request_bias */ 2:
                    message.activeRequestBias = RuntimeDouble.internalBinaryRead(reader, reader.uint32(), options, message.activeRequestBias);
                    break;
                case /* envoy.config.cluster.v3.Cluster.SlowStartConfig slow_start_config */ 3:
                    message.slowStartConfig = Cluster_SlowStartConfig.internalBinaryRead(reader, reader.uint32(), options, message.slowStartConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_LeastRequestLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value choice_count = 1; */
        if (message.choiceCount)
            UInt32Value.internalBinaryWrite(message.choiceCount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeDouble active_request_bias = 2; */
        if (message.activeRequestBias)
            RuntimeDouble.internalBinaryWrite(message.activeRequestBias, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.SlowStartConfig slow_start_config = 3; */
        if (message.slowStartConfig)
            Cluster_SlowStartConfig.internalBinaryWrite(message.slowStartConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.LeastRequestLbConfig
 */
export const Cluster_LeastRequestLbConfig = new Cluster_LeastRequestLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_RingHashLbConfig$Type extends MessageType<Cluster_RingHashLbConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.RingHashLbConfig", [
            { no: 1, name: "minimum_ring_size", kind: "message", T: () => UInt64Value, options: { "validate.rules": { uint64: { lte: "8388608" } } } },
            { no: 3, name: "hash_function", kind: "enum", T: () => ["envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction", Cluster_RingHashLbConfig_HashFunction], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 4, name: "maximum_ring_size", kind: "message", T: () => UInt64Value, options: { "validate.rules": { uint64: { lte: "8388608" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.RingHashLbConfig" } });
    }
    create(value?: PartialMessage<Cluster_RingHashLbConfig>): Cluster_RingHashLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hashFunction = 0;
        if (value !== undefined)
            reflectionMergePartial<Cluster_RingHashLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_RingHashLbConfig): Cluster_RingHashLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt64Value minimum_ring_size */ 1:
                    message.minimumRingSize = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.minimumRingSize);
                    break;
                case /* envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function */ 3:
                    message.hashFunction = reader.int32();
                    break;
                case /* google.protobuf.UInt64Value maximum_ring_size */ 4:
                    message.maximumRingSize = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.maximumRingSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_RingHashLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt64Value minimum_ring_size = 1; */
        if (message.minimumRingSize)
            UInt64Value.internalBinaryWrite(message.minimumRingSize, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3; */
        if (message.hashFunction !== 0)
            writer.tag(3, WireType.Varint).int32(message.hashFunction);
        /* google.protobuf.UInt64Value maximum_ring_size = 4; */
        if (message.maximumRingSize)
            UInt64Value.internalBinaryWrite(message.maximumRingSize, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.RingHashLbConfig
 */
export const Cluster_RingHashLbConfig = new Cluster_RingHashLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_MaglevLbConfig$Type extends MessageType<Cluster_MaglevLbConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.MaglevLbConfig", [
            { no: 1, name: "table_size", kind: "message", T: () => UInt64Value, options: { "validate.rules": { uint64: { lte: "5000011" } } } }
        ]);
    }
    create(value?: PartialMessage<Cluster_MaglevLbConfig>): Cluster_MaglevLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cluster_MaglevLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_MaglevLbConfig): Cluster_MaglevLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt64Value table_size */ 1:
                    message.tableSize = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.tableSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_MaglevLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt64Value table_size = 1; */
        if (message.tableSize)
            UInt64Value.internalBinaryWrite(message.tableSize, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.MaglevLbConfig
 */
export const Cluster_MaglevLbConfig = new Cluster_MaglevLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_OriginalDstLbConfig$Type extends MessageType<Cluster_OriginalDstLbConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.OriginalDstLbConfig", [
            { no: 1, name: "use_http_header", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "http_header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "upstream_port_override", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 65535 } } } },
            { no: 4, name: "metadata_key", kind: "message", T: () => MetadataKey }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.OriginalDstLbConfig" } });
    }
    create(value?: PartialMessage<Cluster_OriginalDstLbConfig>): Cluster_OriginalDstLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.useHttpHeader = false;
        message.httpHeaderName = "";
        if (value !== undefined)
            reflectionMergePartial<Cluster_OriginalDstLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_OriginalDstLbConfig): Cluster_OriginalDstLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool use_http_header */ 1:
                    message.useHttpHeader = reader.bool();
                    break;
                case /* string http_header_name */ 2:
                    message.httpHeaderName = reader.string();
                    break;
                case /* google.protobuf.UInt32Value upstream_port_override */ 3:
                    message.upstreamPortOverride = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.upstreamPortOverride);
                    break;
                case /* envoy.type.metadata.v3.MetadataKey metadata_key */ 4:
                    message.metadataKey = MetadataKey.internalBinaryRead(reader, reader.uint32(), options, message.metadataKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_OriginalDstLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool use_http_header = 1; */
        if (message.useHttpHeader !== false)
            writer.tag(1, WireType.Varint).bool(message.useHttpHeader);
        /* string http_header_name = 2; */
        if (message.httpHeaderName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.httpHeaderName);
        /* google.protobuf.UInt32Value upstream_port_override = 3; */
        if (message.upstreamPortOverride)
            UInt32Value.internalBinaryWrite(message.upstreamPortOverride, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.metadata.v3.MetadataKey metadata_key = 4; */
        if (message.metadataKey)
            MetadataKey.internalBinaryWrite(message.metadataKey, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.OriginalDstLbConfig
 */
export const Cluster_OriginalDstLbConfig = new Cluster_OriginalDstLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_CommonLbConfig$Type extends MessageType<Cluster_CommonLbConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.CommonLbConfig", [
            { no: 1, name: "healthy_panic_threshold", kind: "message", T: () => Percent },
            { no: 2, name: "zone_aware_lb_config", kind: "message", oneof: "localityConfigSpecifier", T: () => Cluster_CommonLbConfig_ZoneAwareLbConfig },
            { no: 3, name: "locality_weighted_lb_config", kind: "message", oneof: "localityConfigSpecifier", T: () => Cluster_CommonLbConfig_LocalityWeightedLbConfig },
            { no: 4, name: "update_merge_window", kind: "message", T: () => Duration },
            { no: 5, name: "ignore_new_hosts_until_first_hc", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "close_connections_on_host_set_change", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "consistent_hashing_lb_config", kind: "message", T: () => Cluster_CommonLbConfig_ConsistentHashingLbConfig },
            { no: 8, name: "override_host_status", kind: "message", T: () => HealthStatusSet }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.CommonLbConfig" } });
    }
    create(value?: PartialMessage<Cluster_CommonLbConfig>): Cluster_CommonLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localityConfigSpecifier = { oneofKind: undefined };
        message.ignoreNewHostsUntilFirstHc = false;
        message.closeConnectionsOnHostSetChange = false;
        if (value !== undefined)
            reflectionMergePartial<Cluster_CommonLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_CommonLbConfig): Cluster_CommonLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.Percent healthy_panic_threshold */ 1:
                    message.healthyPanicThreshold = Percent.internalBinaryRead(reader, reader.uint32(), options, message.healthyPanicThreshold);
                    break;
                case /* envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config */ 2:
                    message.localityConfigSpecifier = {
                        oneofKind: "zoneAwareLbConfig",
                        zoneAwareLbConfig: Cluster_CommonLbConfig_ZoneAwareLbConfig.internalBinaryRead(reader, reader.uint32(), options, (message.localityConfigSpecifier as any).zoneAwareLbConfig)
                    };
                    break;
                case /* envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config */ 3:
                    message.localityConfigSpecifier = {
                        oneofKind: "localityWeightedLbConfig",
                        localityWeightedLbConfig: Cluster_CommonLbConfig_LocalityWeightedLbConfig.internalBinaryRead(reader, reader.uint32(), options, (message.localityConfigSpecifier as any).localityWeightedLbConfig)
                    };
                    break;
                case /* google.protobuf.Duration update_merge_window */ 4:
                    message.updateMergeWindow = Duration.internalBinaryRead(reader, reader.uint32(), options, message.updateMergeWindow);
                    break;
                case /* bool ignore_new_hosts_until_first_hc */ 5:
                    message.ignoreNewHostsUntilFirstHc = reader.bool();
                    break;
                case /* bool close_connections_on_host_set_change */ 6:
                    message.closeConnectionsOnHostSetChange = reader.bool();
                    break;
                case /* envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config */ 7:
                    message.consistentHashingLbConfig = Cluster_CommonLbConfig_ConsistentHashingLbConfig.internalBinaryRead(reader, reader.uint32(), options, message.consistentHashingLbConfig);
                    break;
                case /* envoy.config.core.v3.HealthStatusSet override_host_status */ 8:
                    message.overrideHostStatus = HealthStatusSet.internalBinaryRead(reader, reader.uint32(), options, message.overrideHostStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_CommonLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.Percent healthy_panic_threshold = 1; */
        if (message.healthyPanicThreshold)
            Percent.internalBinaryWrite(message.healthyPanicThreshold, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2; */
        if (message.localityConfigSpecifier.oneofKind === "zoneAwareLbConfig")
            Cluster_CommonLbConfig_ZoneAwareLbConfig.internalBinaryWrite(message.localityConfigSpecifier.zoneAwareLbConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3; */
        if (message.localityConfigSpecifier.oneofKind === "localityWeightedLbConfig")
            Cluster_CommonLbConfig_LocalityWeightedLbConfig.internalBinaryWrite(message.localityConfigSpecifier.localityWeightedLbConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration update_merge_window = 4; */
        if (message.updateMergeWindow)
            Duration.internalBinaryWrite(message.updateMergeWindow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool ignore_new_hosts_until_first_hc = 5; */
        if (message.ignoreNewHostsUntilFirstHc !== false)
            writer.tag(5, WireType.Varint).bool(message.ignoreNewHostsUntilFirstHc);
        /* bool close_connections_on_host_set_change = 6; */
        if (message.closeConnectionsOnHostSetChange !== false)
            writer.tag(6, WireType.Varint).bool(message.closeConnectionsOnHostSetChange);
        /* envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7; */
        if (message.consistentHashingLbConfig)
            Cluster_CommonLbConfig_ConsistentHashingLbConfig.internalBinaryWrite(message.consistentHashingLbConfig, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HealthStatusSet override_host_status = 8; */
        if (message.overrideHostStatus)
            HealthStatusSet.internalBinaryWrite(message.overrideHostStatus, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.CommonLbConfig
 */
export const Cluster_CommonLbConfig = new Cluster_CommonLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_CommonLbConfig_ZoneAwareLbConfig$Type extends MessageType<Cluster_CommonLbConfig_ZoneAwareLbConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig", [
            { no: 1, name: "routing_enabled", kind: "message", T: () => Percent },
            { no: 2, name: "min_cluster_size", kind: "message", T: () => UInt64Value },
            { no: 3, name: "fail_traffic_on_panic", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig" } });
    }
    create(value?: PartialMessage<Cluster_CommonLbConfig_ZoneAwareLbConfig>): Cluster_CommonLbConfig_ZoneAwareLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.failTrafficOnPanic = false;
        if (value !== undefined)
            reflectionMergePartial<Cluster_CommonLbConfig_ZoneAwareLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_CommonLbConfig_ZoneAwareLbConfig): Cluster_CommonLbConfig_ZoneAwareLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.Percent routing_enabled */ 1:
                    message.routingEnabled = Percent.internalBinaryRead(reader, reader.uint32(), options, message.routingEnabled);
                    break;
                case /* google.protobuf.UInt64Value min_cluster_size */ 2:
                    message.minClusterSize = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.minClusterSize);
                    break;
                case /* bool fail_traffic_on_panic */ 3:
                    message.failTrafficOnPanic = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_CommonLbConfig_ZoneAwareLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.Percent routing_enabled = 1; */
        if (message.routingEnabled)
            Percent.internalBinaryWrite(message.routingEnabled, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt64Value min_cluster_size = 2; */
        if (message.minClusterSize)
            UInt64Value.internalBinaryWrite(message.minClusterSize, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool fail_traffic_on_panic = 3; */
        if (message.failTrafficOnPanic !== false)
            writer.tag(3, WireType.Varint).bool(message.failTrafficOnPanic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig
 */
export const Cluster_CommonLbConfig_ZoneAwareLbConfig = new Cluster_CommonLbConfig_ZoneAwareLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_CommonLbConfig_LocalityWeightedLbConfig$Type extends MessageType<Cluster_CommonLbConfig_LocalityWeightedLbConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig", [], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig" } });
    }
    create(value?: PartialMessage<Cluster_CommonLbConfig_LocalityWeightedLbConfig>): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cluster_CommonLbConfig_LocalityWeightedLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_CommonLbConfig_LocalityWeightedLbConfig): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Cluster_CommonLbConfig_LocalityWeightedLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig
 */
export const Cluster_CommonLbConfig_LocalityWeightedLbConfig = new Cluster_CommonLbConfig_LocalityWeightedLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_CommonLbConfig_ConsistentHashingLbConfig$Type extends MessageType<Cluster_CommonLbConfig_ConsistentHashingLbConfig> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig", [
            { no: 1, name: "use_hostname_for_hashing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "hash_balance_factor", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 100 } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.CommonLbConfig.ConsistentHashingLbConfig" } });
    }
    create(value?: PartialMessage<Cluster_CommonLbConfig_ConsistentHashingLbConfig>): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.useHostnameForHashing = false;
        if (value !== undefined)
            reflectionMergePartial<Cluster_CommonLbConfig_ConsistentHashingLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_CommonLbConfig_ConsistentHashingLbConfig): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool use_hostname_for_hashing */ 1:
                    message.useHostnameForHashing = reader.bool();
                    break;
                case /* google.protobuf.UInt32Value hash_balance_factor */ 2:
                    message.hashBalanceFactor = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.hashBalanceFactor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_CommonLbConfig_ConsistentHashingLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool use_hostname_for_hashing = 1; */
        if (message.useHostnameForHashing !== false)
            writer.tag(1, WireType.Varint).bool(message.useHostnameForHashing);
        /* google.protobuf.UInt32Value hash_balance_factor = 2; */
        if (message.hashBalanceFactor)
            UInt32Value.internalBinaryWrite(message.hashBalanceFactor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig
 */
export const Cluster_CommonLbConfig_ConsistentHashingLbConfig = new Cluster_CommonLbConfig_ConsistentHashingLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_RefreshRate$Type extends MessageType<Cluster_RefreshRate> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.RefreshRate", [
            { no: 1, name: "base_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gt: { nanos: 1000000 } } } } },
            { no: 2, name: "max_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: { nanos: 1000000 } } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Cluster.RefreshRate" } });
    }
    create(value?: PartialMessage<Cluster_RefreshRate>): Cluster_RefreshRate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cluster_RefreshRate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_RefreshRate): Cluster_RefreshRate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration base_interval */ 1:
                    message.baseInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.baseInterval);
                    break;
                case /* google.protobuf.Duration max_interval */ 2:
                    message.maxInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxInterval);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_RefreshRate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration base_interval = 1; */
        if (message.baseInterval)
            Duration.internalBinaryWrite(message.baseInterval, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_interval = 2; */
        if (message.maxInterval)
            Duration.internalBinaryWrite(message.maxInterval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.RefreshRate
 */
export const Cluster_RefreshRate = new Cluster_RefreshRate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_PreconnectPolicy$Type extends MessageType<Cluster_PreconnectPolicy> {
    constructor() {
        super("envoy.config.cluster.v3.Cluster.PreconnectPolicy", [
            { no: 1, name: "per_upstream_preconnect_ratio", kind: "message", T: () => DoubleValue, options: { "validate.rules": { double: { lte: 3, gte: 1 } } } },
            { no: 2, name: "predictive_preconnect_ratio", kind: "message", T: () => DoubleValue, options: { "validate.rules": { double: { lte: 3, gte: 1 } } } }
        ]);
    }
    create(value?: PartialMessage<Cluster_PreconnectPolicy>): Cluster_PreconnectPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cluster_PreconnectPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_PreconnectPolicy): Cluster_PreconnectPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.DoubleValue per_upstream_preconnect_ratio */ 1:
                    message.perUpstreamPreconnectRatio = DoubleValue.internalBinaryRead(reader, reader.uint32(), options, message.perUpstreamPreconnectRatio);
                    break;
                case /* google.protobuf.DoubleValue predictive_preconnect_ratio */ 2:
                    message.predictivePreconnectRatio = DoubleValue.internalBinaryRead(reader, reader.uint32(), options, message.predictivePreconnectRatio);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_PreconnectPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1; */
        if (message.perUpstreamPreconnectRatio)
            DoubleValue.internalBinaryWrite(message.perUpstreamPreconnectRatio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.DoubleValue predictive_preconnect_ratio = 2; */
        if (message.predictivePreconnectRatio)
            DoubleValue.internalBinaryWrite(message.predictivePreconnectRatio, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.Cluster.PreconnectPolicy
 */
export const Cluster_PreconnectPolicy = new Cluster_PreconnectPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadBalancingPolicy$Type extends MessageType<LoadBalancingPolicy> {
    constructor() {
        super("envoy.config.cluster.v3.LoadBalancingPolicy", [
            { no: 1, name: "policies", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LoadBalancingPolicy_Policy }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.LoadBalancingPolicy" } });
    }
    create(value?: PartialMessage<LoadBalancingPolicy>): LoadBalancingPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.policies = [];
        if (value !== undefined)
            reflectionMergePartial<LoadBalancingPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadBalancingPolicy): LoadBalancingPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.cluster.v3.LoadBalancingPolicy.Policy policies */ 1:
                    message.policies.push(LoadBalancingPolicy_Policy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadBalancingPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.cluster.v3.LoadBalancingPolicy.Policy policies = 1; */
        for (let i = 0; i < message.policies.length; i++)
            LoadBalancingPolicy_Policy.internalBinaryWrite(message.policies[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.LoadBalancingPolicy
 */
export const LoadBalancingPolicy = new LoadBalancingPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadBalancingPolicy_Policy$Type extends MessageType<LoadBalancingPolicy_Policy> {
    constructor() {
        super("envoy.config.cluster.v3.LoadBalancingPolicy.Policy", [
            { no: 4, name: "typed_extension_config", kind: "message", T: () => TypedExtensionConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.LoadBalancingPolicy.Policy" } });
    }
    create(value?: PartialMessage<LoadBalancingPolicy_Policy>): LoadBalancingPolicy_Policy {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LoadBalancingPolicy_Policy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadBalancingPolicy_Policy): LoadBalancingPolicy_Policy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.TypedExtensionConfig typed_extension_config */ 4:
                    message.typedExtensionConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.typedExtensionConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadBalancingPolicy_Policy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.TypedExtensionConfig typed_extension_config = 4; */
        if (message.typedExtensionConfig)
            TypedExtensionConfig.internalBinaryWrite(message.typedExtensionConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.LoadBalancingPolicy.Policy
 */
export const LoadBalancingPolicy_Policy = new LoadBalancingPolicy_Policy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpstreamConnectionOptions$Type extends MessageType<UpstreamConnectionOptions> {
    constructor() {
        super("envoy.config.cluster.v3.UpstreamConnectionOptions", [
            { no: 1, name: "tcp_keepalive", kind: "message", T: () => TcpKeepalive },
            { no: 2, name: "set_local_interface_name_on_upstream_connections", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.UpstreamConnectionOptions" } });
    }
    create(value?: PartialMessage<UpstreamConnectionOptions>): UpstreamConnectionOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setLocalInterfaceNameOnUpstreamConnections = false;
        if (value !== undefined)
            reflectionMergePartial<UpstreamConnectionOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpstreamConnectionOptions): UpstreamConnectionOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.TcpKeepalive tcp_keepalive */ 1:
                    message.tcpKeepalive = TcpKeepalive.internalBinaryRead(reader, reader.uint32(), options, message.tcpKeepalive);
                    break;
                case /* bool set_local_interface_name_on_upstream_connections */ 2:
                    message.setLocalInterfaceNameOnUpstreamConnections = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpstreamConnectionOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.TcpKeepalive tcp_keepalive = 1; */
        if (message.tcpKeepalive)
            TcpKeepalive.internalBinaryWrite(message.tcpKeepalive, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool set_local_interface_name_on_upstream_connections = 2; */
        if (message.setLocalInterfaceNameOnUpstreamConnections !== false)
            writer.tag(2, WireType.Varint).bool(message.setLocalInterfaceNameOnUpstreamConnections);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.UpstreamConnectionOptions
 */
export const UpstreamConnectionOptions = new UpstreamConnectionOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackClusterStats$Type extends MessageType<TrackClusterStats> {
    constructor() {
        super("envoy.config.cluster.v3.TrackClusterStats", [
            { no: 1, name: "timeout_budgets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "request_response_sizes", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TrackClusterStats>): TrackClusterStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeoutBudgets = false;
        message.requestResponseSizes = false;
        if (value !== undefined)
            reflectionMergePartial<TrackClusterStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackClusterStats): TrackClusterStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool timeout_budgets */ 1:
                    message.timeoutBudgets = reader.bool();
                    break;
                case /* bool request_response_sizes */ 2:
                    message.requestResponseSizes = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackClusterStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool timeout_budgets = 1; */
        if (message.timeoutBudgets !== false)
            writer.tag(1, WireType.Varint).bool(message.timeoutBudgets);
        /* bool request_response_sizes = 2; */
        if (message.requestResponseSizes !== false)
            writer.tag(2, WireType.Varint).bool(message.requestResponseSizes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.cluster.v3.TrackClusterStats
 */
export const TrackClusterStats = new TrackClusterStats$Type();
