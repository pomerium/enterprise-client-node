// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies
// @generated from protobuf file "envoy/config/core/v3/config_source.proto" (package "envoy.config.core.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../../../google/protobuf/any";
import { Authority } from "../../../../xds/core/v3/authority";
import { WatchedDirectory } from "./base";
import { DoubleValue } from "../../../../google/protobuf/wrappers";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { TypedExtensionConfig } from "./extension";
import { Duration } from "../../../../google/protobuf/duration";
import { GrpcService } from "./grpc_service";
/**
 * API configuration source. This identifies the API type and cluster that Envoy
 * will use to fetch an xDS API.
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.config.core.v3.ApiConfigSource
 */
export interface ApiConfigSource {
    /**
     * API type (gRPC, REST, delta gRPC)
     *
     * @generated from protobuf field: envoy.config.core.v3.ApiConfigSource.ApiType api_type = 1;
     */
    apiType: ApiConfigSource_ApiType;
    /**
     * API version for xDS transport protocol. This describes the xDS gRPC/REST
     * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
     *
     * @generated from protobuf field: envoy.config.core.v3.ApiVersion transport_api_version = 8;
     */
    transportApiVersion: ApiVersion;
    /**
     * Cluster names should be used only with REST. If > 1
     * cluster is defined, clusters will be cycled through if any kind of failure
     * occurs.
     *
     * .. note::
     *
     *  The cluster with name ``cluster_name`` must be statically defined and its
     *  type must not be ``EDS``.
     *
     * @generated from protobuf field: repeated string cluster_names = 2;
     */
    clusterNames: string[];
    /**
     * Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
     * services will be cycled through if any kind of failure occurs.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.GrpcService grpc_services = 4;
     */
    grpcServices: GrpcService[];
    /**
     * For REST APIs, the delay between successive polls.
     *
     * @generated from protobuf field: google.protobuf.Duration refresh_delay = 3;
     */
    refreshDelay?: Duration;
    /**
     * For REST APIs, the request timeout. If not set, a default value of 1s will be used.
     *
     * @generated from protobuf field: google.protobuf.Duration request_timeout = 5;
     */
    requestTimeout?: Duration;
    /**
     * For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
     * rate limited.
     *
     * @generated from protobuf field: envoy.config.core.v3.RateLimitSettings rate_limit_settings = 6;
     */
    rateLimitSettings?: RateLimitSettings;
    /**
     * Skip the node identifier in subsequent discovery requests for streaming gRPC config types.
     *
     * @generated from protobuf field: bool set_node_on_first_message_only = 7;
     */
    setNodeOnFirstMessageOnly: boolean;
    /**
     * A list of config validators that will be executed when a new update is
     * received from the ApiConfigSource. Note that each validator handles a
     * specific xDS service type, and only the validators corresponding to the
     * type url (in ``:ref: DiscoveryResponse`` or ``:ref: DeltaDiscoveryResponse``)
     * will be invoked.
     * If the validator returns false or throws an exception, the config will be rejected by
     * the client, and a NACK will be sent.
     * [#extension-category: envoy.config.validators]
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.TypedExtensionConfig config_validators = 9;
     */
    configValidators: TypedExtensionConfig[];
}
/**
 * APIs may be fetched via either REST or gRPC.
 *
 * @generated from protobuf enum envoy.config.core.v3.ApiConfigSource.ApiType
 */
export enum ApiConfigSource_ApiType {
    /**
     * Ideally this would be 'reserved 0' but one can't reserve the default
     * value. Instead we throw an exception if this is ever used.
     *
     * @deprecated
     * @generated from protobuf enum value: DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE = 0 [deprecated = true];
     */
    DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE = 0,
    /**
     * REST-JSON v2 API. The `canonical JSON encoding
     * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
     * the v2 protos is used.
     *
     * @generated from protobuf enum value: REST = 1;
     */
    REST = 1,
    /**
     * SotW gRPC service.
     *
     * @generated from protobuf enum value: GRPC = 2;
     */
    GRPC = 2,
    /**
     * Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
     * rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
     * with every update, the xDS server only sends what has changed since the last update.
     *
     * @generated from protobuf enum value: DELTA_GRPC = 3;
     */
    DELTA_GRPC = 3,
    /**
     * SotW xDS gRPC with ADS. All resources which resolve to this configuration source will be
     * multiplexed on a single connection to an ADS endpoint.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf enum value: AGGREGATED_GRPC = 5;
     */
    AGGREGATED_GRPC = 5,
    /**
     * Delta xDS gRPC with ADS. All resources which resolve to this configuration source will be
     * multiplexed on a single connection to an ADS endpoint.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf enum value: AGGREGATED_DELTA_GRPC = 6;
     */
    AGGREGATED_DELTA_GRPC = 6
}
/**
 * Aggregated Discovery Service (ADS) options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
 * specify that ADS is to be used.
 *
 * @generated from protobuf message envoy.config.core.v3.AggregatedConfigSource
 */
export interface AggregatedConfigSource {
}
/**
 * [#not-implemented-hide:]
 * Self-referencing config source options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
 * specify that other data can be obtained from the same server.
 *
 * @generated from protobuf message envoy.config.core.v3.SelfConfigSource
 */
export interface SelfConfigSource {
    /**
     * API version for xDS transport protocol. This describes the xDS gRPC/REST
     * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
     *
     * @generated from protobuf field: envoy.config.core.v3.ApiVersion transport_api_version = 1;
     */
    transportApiVersion: ApiVersion;
}
/**
 * Rate Limit settings to be applied for discovery requests made by Envoy.
 *
 * @generated from protobuf message envoy.config.core.v3.RateLimitSettings
 */
export interface RateLimitSettings {
    /**
     * Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
     * default value of 100 will be used.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_tokens = 1;
     */
    maxTokens?: UInt32Value;
    /**
     * Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
     * per second will be used. The minimal fill rate is once per year. Lower
     * fill rates will be set to once per year.
     *
     * @generated from protobuf field: google.protobuf.DoubleValue fill_rate = 2;
     */
    fillRate?: DoubleValue;
}
/**
 * Local filesystem path configuration source.
 *
 * @generated from protobuf message envoy.config.core.v3.PathConfigSource
 */
export interface PathConfigSource {
    /**
     * Path on the filesystem to source and watch for configuration updates.
     * When sourcing configuration for a :ref:`secret <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.Secret>`,
     * the certificate and key files are also watched for updates.
     *
     * .. note::
     *
     *  The path to the source must exist at config load time.
     *
     * .. note::
     *
     *   If ``watched_directory`` is *not* configured, Envoy will watch the file path for *moves*.
     *   This is because in general only moves are atomic. The same method of swapping files as is
     *   demonstrated in the :ref:`runtime documentation <config_runtime_symbolic_link_swap>` can be
     *   used here also. If ``watched_directory`` is configured, no watch will be placed directly on
     *   this path. Instead, the configured ``watched_directory`` will be used to trigger reloads of
     *   this path. This is required in certain deployment scenarios. See below for more information.
     *
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * If configured, this directory will be watched for *moves*. When an entry in this directory is
     * moved to, the ``path`` will be reloaded. This is required in certain deployment scenarios.
     *
     * Specifically, if trying to load an xDS resource using a
     * `Kubernetes ConfigMap <https://kubernetes.io/docs/concepts/configuration/configmap/>`_, the
     * following configuration might be used:
     * 1. Store xds.yaml inside a ConfigMap.
     * 2. Mount the ConfigMap to ``/config_map/xds``
     * 3. Configure path ``/config_map/xds/xds.yaml``
     * 4. Configure watched directory ``/config_map/xds``
     *
     * The above configuration will ensure that Envoy watches the owning directory for moves which is
     * required due to how Kubernetes manages ConfigMap symbolic links during atomic updates.
     *
     * @generated from protobuf field: envoy.config.core.v3.WatchedDirectory watched_directory = 2;
     */
    watchedDirectory?: WatchedDirectory;
}
/**
 * Configuration for :ref:`listeners <config_listeners>`, :ref:`clusters
 * <config_cluster_manager>`, :ref:`routes
 * <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`, :ref:`endpoints
 * <arch_overview_service_discovery>` etc. may either be sourced from the
 * filesystem or from an xDS API source. Filesystem configs are watched with
 * inotify for updates.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.config.core.v3.ConfigSource
 */
export interface ConfigSource {
    /**
     * Authorities that this config source may be used for. An authority specified in a xdstp:// URL
     * is resolved to a ``ConfigSource`` prior to configuration fetch. This field provides the
     * association between authority name and configuration source.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: repeated xds.core.v3.Authority authorities = 7;
     */
    authorities: Authority[];
    /**
     * @generated from protobuf oneof: config_source_specifier
     */
    configSourceSpecifier: {
        oneofKind: "path";
        /**
         * Deprecated in favor of ``path_config_source``. Use that field instead.
         *
         * @deprecated
         * @generated from protobuf field: string path = 1 [deprecated = true];
         */
        path: string;
    } | {
        oneofKind: "pathConfigSource";
        /**
         * Local filesystem path configuration source.
         *
         * @generated from protobuf field: envoy.config.core.v3.PathConfigSource path_config_source = 8;
         */
        pathConfigSource: PathConfigSource;
    } | {
        oneofKind: "apiConfigSource";
        /**
         * API configuration source.
         *
         * @generated from protobuf field: envoy.config.core.v3.ApiConfigSource api_config_source = 2;
         */
        apiConfigSource: ApiConfigSource;
    } | {
        oneofKind: "ads";
        /**
         * When set, ADS will be used to fetch resources. The ADS API configuration
         * source in the bootstrap configuration is used.
         *
         * @generated from protobuf field: envoy.config.core.v3.AggregatedConfigSource ads = 3;
         */
        ads: AggregatedConfigSource;
    } | {
        oneofKind: "self";
        /**
         * [#not-implemented-hide:]
         * When set, the client will access the resources from the same server it got the
         * ConfigSource from, although not necessarily from the same stream. This is similar to the
         * :ref:`ads<envoy_v3_api_field.ConfigSource.ads>` field, except that the client may use a
         * different stream to the same server. As a result, this field can be used for things
         * like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.)
         * LDS to RDS on the same server without requiring the management server to know its name
         * or required credentials.
         * [#next-major-version: In xDS v3, consider replacing the ads field with this one, since
         * this field can implicitly mean to use the same stream in the case where the ConfigSource
         * is provided via ADS and the specified data can also be obtained via ADS.]
         *
         * @generated from protobuf field: envoy.config.core.v3.SelfConfigSource self = 5;
         */
        self: SelfConfigSource;
    } | {
        oneofKind: undefined;
    };
    /**
     * When this timeout is specified, Envoy will wait no longer than the specified time for first
     * config response on this xDS subscription during the :ref:`initialization process
     * <arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
     * initialization phase, even if the first config is not delivered yet. The timer is activated
     * when the xDS API subscription starts, and is disarmed on first config update or on error. 0
     * means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
     * timeout applies). The default is 15s.
     *
     * @generated from protobuf field: google.protobuf.Duration initial_fetch_timeout = 4;
     */
    initialFetchTimeout?: Duration;
    /**
     * API version for xDS resources. This implies the type URLs that the client
     * will request for resources and the resource type that the client will in
     * turn expect to be delivered.
     *
     * @generated from protobuf field: envoy.config.core.v3.ApiVersion resource_api_version = 6;
     */
    resourceApiVersion: ApiVersion;
}
/**
 * Configuration source specifier for a late-bound extension configuration. The
 * parent resource is warmed until all the initial extension configurations are
 * received, unless the flag to apply the default configuration is set.
 * Subsequent extension updates are atomic on a per-worker basis. Once an
 * extension configuration is applied to a request or a connection, it remains
 * constant for the duration of processing. If the initial delivery of the
 * extension configuration fails, due to a timeout for example, the optional
 * default configuration is applied. Without a default configuration, the
 * extension is disabled, until an extension configuration is received. The
 * behavior of a disabled extension depends on the context. For example, a
 * filter chain with a disabled extension filter rejects all incoming streams.
 *
 * @generated from protobuf message envoy.config.core.v3.ExtensionConfigSource
 */
export interface ExtensionConfigSource {
    /**
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource config_source = 1;
     */
    configSource?: ConfigSource;
    /**
     * Optional default configuration to use as the initial configuration if
     * there is a failure to receive the initial extension configuration or if
     * ``apply_default_config_without_warming`` flag is set.
     *
     * @generated from protobuf field: google.protobuf.Any default_config = 2;
     */
    defaultConfig?: Any;
    /**
     * Use the default config as the initial configuration without warming and
     * waiting for the first discovery response. Requires the default configuration
     * to be supplied.
     *
     * @generated from protobuf field: bool apply_default_config_without_warming = 3;
     */
    applyDefaultConfigWithoutWarming: boolean;
    /**
     * A set of permitted extension type URLs. Extension configuration updates are rejected
     * if they do not match any type URL in the set.
     *
     * @generated from protobuf field: repeated string type_urls = 4;
     */
    typeUrls: string[];
}
// [#protodoc-title: Configuration sources]

/**
 * xDS API and non-xDS services version. This is used to describe both resource and transport
 * protocol versions (in distinct configuration fields).
 *
 * @generated from protobuf enum envoy.config.core.v3.ApiVersion
 */
export enum ApiVersion {
    /**
     * When not specified, we assume v2, to ease migration to Envoy's stable API
     * versioning. If a client does not support v2 (e.g. due to deprecation), this
     * is an invalid value.
     *
     * @deprecated
     * @generated from protobuf enum value: AUTO = 0 [deprecated = true];
     */
    AUTO = 0,
    /**
     * Use xDS v2 API.
     *
     * @deprecated
     * @generated from protobuf enum value: V2 = 1 [deprecated = true];
     */
    V2 = 1,
    /**
     * Use xDS v3 API.
     *
     * @generated from protobuf enum value: V3 = 2;
     */
    V3 = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ApiConfigSource$Type extends MessageType<ApiConfigSource> {
    constructor() {
        super("envoy.config.core.v3.ApiConfigSource", [
            { no: 1, name: "api_type", kind: "enum", T: () => ["envoy.config.core.v3.ApiConfigSource.ApiType", ApiConfigSource_ApiType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 8, name: "transport_api_version", kind: "enum", T: () => ["envoy.config.core.v3.ApiVersion", ApiVersion], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "cluster_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "grpc_services", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GrpcService },
            { no: 3, name: "refresh_delay", kind: "message", T: () => Duration },
            { no: 5, name: "request_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 6, name: "rate_limit_settings", kind: "message", T: () => RateLimitSettings },
            { no: 7, name: "set_node_on_first_message_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "config_validators", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TypedExtensionConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.ApiConfigSource" } });
    }
    create(value?: PartialMessage<ApiConfigSource>): ApiConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiType = 0;
        message.transportApiVersion = 0;
        message.clusterNames = [];
        message.grpcServices = [];
        message.setNodeOnFirstMessageOnly = false;
        message.configValidators = [];
        if (value !== undefined)
            reflectionMergePartial<ApiConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApiConfigSource): ApiConfigSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ApiConfigSource.ApiType api_type */ 1:
                    message.apiType = reader.int32();
                    break;
                case /* envoy.config.core.v3.ApiVersion transport_api_version */ 8:
                    message.transportApiVersion = reader.int32();
                    break;
                case /* repeated string cluster_names */ 2:
                    message.clusterNames.push(reader.string());
                    break;
                case /* repeated envoy.config.core.v3.GrpcService grpc_services */ 4:
                    message.grpcServices.push(GrpcService.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Duration refresh_delay */ 3:
                    message.refreshDelay = Duration.internalBinaryRead(reader, reader.uint32(), options, message.refreshDelay);
                    break;
                case /* google.protobuf.Duration request_timeout */ 5:
                    message.requestTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.requestTimeout);
                    break;
                case /* envoy.config.core.v3.RateLimitSettings rate_limit_settings */ 6:
                    message.rateLimitSettings = RateLimitSettings.internalBinaryRead(reader, reader.uint32(), options, message.rateLimitSettings);
                    break;
                case /* bool set_node_on_first_message_only */ 7:
                    message.setNodeOnFirstMessageOnly = reader.bool();
                    break;
                case /* repeated envoy.config.core.v3.TypedExtensionConfig config_validators */ 9:
                    message.configValidators.push(TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApiConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ApiConfigSource.ApiType api_type = 1; */
        if (message.apiType !== 0)
            writer.tag(1, WireType.Varint).int32(message.apiType);
        /* envoy.config.core.v3.ApiVersion transport_api_version = 8; */
        if (message.transportApiVersion !== 0)
            writer.tag(8, WireType.Varint).int32(message.transportApiVersion);
        /* repeated string cluster_names = 2; */
        for (let i = 0; i < message.clusterNames.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterNames[i]);
        /* repeated envoy.config.core.v3.GrpcService grpc_services = 4; */
        for (let i = 0; i < message.grpcServices.length; i++)
            GrpcService.internalBinaryWrite(message.grpcServices[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration refresh_delay = 3; */
        if (message.refreshDelay)
            Duration.internalBinaryWrite(message.refreshDelay, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration request_timeout = 5; */
        if (message.requestTimeout)
            Duration.internalBinaryWrite(message.requestTimeout, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RateLimitSettings rate_limit_settings = 6; */
        if (message.rateLimitSettings)
            RateLimitSettings.internalBinaryWrite(message.rateLimitSettings, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool set_node_on_first_message_only = 7; */
        if (message.setNodeOnFirstMessageOnly !== false)
            writer.tag(7, WireType.Varint).bool(message.setNodeOnFirstMessageOnly);
        /* repeated envoy.config.core.v3.TypedExtensionConfig config_validators = 9; */
        for (let i = 0; i < message.configValidators.length; i++)
            TypedExtensionConfig.internalBinaryWrite(message.configValidators[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.ApiConfigSource
 */
export const ApiConfigSource = new ApiConfigSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregatedConfigSource$Type extends MessageType<AggregatedConfigSource> {
    constructor() {
        super("envoy.config.core.v3.AggregatedConfigSource", [], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.AggregatedConfigSource" } });
    }
    create(value?: PartialMessage<AggregatedConfigSource>): AggregatedConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AggregatedConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregatedConfigSource): AggregatedConfigSource {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AggregatedConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.AggregatedConfigSource
 */
export const AggregatedConfigSource = new AggregatedConfigSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfConfigSource$Type extends MessageType<SelfConfigSource> {
    constructor() {
        super("envoy.config.core.v3.SelfConfigSource", [
            { no: 1, name: "transport_api_version", kind: "enum", T: () => ["envoy.config.core.v3.ApiVersion", ApiVersion], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.SelfConfigSource" } });
    }
    create(value?: PartialMessage<SelfConfigSource>): SelfConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transportApiVersion = 0;
        if (value !== undefined)
            reflectionMergePartial<SelfConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfConfigSource): SelfConfigSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ApiVersion transport_api_version */ 1:
                    message.transportApiVersion = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ApiVersion transport_api_version = 1; */
        if (message.transportApiVersion !== 0)
            writer.tag(1, WireType.Varint).int32(message.transportApiVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.SelfConfigSource
 */
export const SelfConfigSource = new SelfConfigSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitSettings$Type extends MessageType<RateLimitSettings> {
    constructor() {
        super("envoy.config.core.v3.RateLimitSettings", [
            { no: 1, name: "max_tokens", kind: "message", T: () => UInt32Value },
            { no: 2, name: "fill_rate", kind: "message", T: () => DoubleValue, options: { "validate.rules": { double: { gt: 0 } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.RateLimitSettings" } });
    }
    create(value?: PartialMessage<RateLimitSettings>): RateLimitSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimitSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitSettings): RateLimitSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value max_tokens */ 1:
                    message.maxTokens = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxTokens);
                    break;
                case /* google.protobuf.DoubleValue fill_rate */ 2:
                    message.fillRate = DoubleValue.internalBinaryRead(reader, reader.uint32(), options, message.fillRate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value max_tokens = 1; */
        if (message.maxTokens)
            UInt32Value.internalBinaryWrite(message.maxTokens, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.DoubleValue fill_rate = 2; */
        if (message.fillRate)
            DoubleValue.internalBinaryWrite(message.fillRate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.RateLimitSettings
 */
export const RateLimitSettings = new RateLimitSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathConfigSource$Type extends MessageType<PathConfigSource> {
    constructor() {
        super("envoy.config.core.v3.PathConfigSource", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "watched_directory", kind: "message", T: () => WatchedDirectory }
        ]);
    }
    create(value?: PartialMessage<PathConfigSource>): PathConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<PathConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PathConfigSource): PathConfigSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* envoy.config.core.v3.WatchedDirectory watched_directory */ 2:
                    message.watchedDirectory = WatchedDirectory.internalBinaryRead(reader, reader.uint32(), options, message.watchedDirectory);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PathConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* envoy.config.core.v3.WatchedDirectory watched_directory = 2; */
        if (message.watchedDirectory)
            WatchedDirectory.internalBinaryWrite(message.watchedDirectory, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.PathConfigSource
 */
export const PathConfigSource = new PathConfigSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigSource$Type extends MessageType<ConfigSource> {
    constructor() {
        super("envoy.config.core.v3.ConfigSource", [
            { no: 7, name: "authorities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Authority },
            { no: 1, name: "path", kind: "scalar", oneof: "configSourceSpecifier", T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 8, name: "path_config_source", kind: "message", oneof: "configSourceSpecifier", T: () => PathConfigSource },
            { no: 2, name: "api_config_source", kind: "message", oneof: "configSourceSpecifier", T: () => ApiConfigSource },
            { no: 3, name: "ads", kind: "message", oneof: "configSourceSpecifier", T: () => AggregatedConfigSource },
            { no: 5, name: "self", kind: "message", oneof: "configSourceSpecifier", T: () => SelfConfigSource },
            { no: 4, name: "initial_fetch_timeout", kind: "message", T: () => Duration },
            { no: 6, name: "resource_api_version", kind: "enum", T: () => ["envoy.config.core.v3.ApiVersion", ApiVersion], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.ConfigSource" } });
    }
    create(value?: PartialMessage<ConfigSource>): ConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorities = [];
        message.configSourceSpecifier = { oneofKind: undefined };
        message.resourceApiVersion = 0;
        if (value !== undefined)
            reflectionMergePartial<ConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigSource): ConfigSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xds.core.v3.Authority authorities */ 7:
                    message.authorities.push(Authority.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string path = 1 [deprecated = true];*/ 1:
                    message.configSourceSpecifier = {
                        oneofKind: "path",
                        path: reader.string()
                    };
                    break;
                case /* envoy.config.core.v3.PathConfigSource path_config_source */ 8:
                    message.configSourceSpecifier = {
                        oneofKind: "pathConfigSource",
                        pathConfigSource: PathConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configSourceSpecifier as any).pathConfigSource)
                    };
                    break;
                case /* envoy.config.core.v3.ApiConfigSource api_config_source */ 2:
                    message.configSourceSpecifier = {
                        oneofKind: "apiConfigSource",
                        apiConfigSource: ApiConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configSourceSpecifier as any).apiConfigSource)
                    };
                    break;
                case /* envoy.config.core.v3.AggregatedConfigSource ads */ 3:
                    message.configSourceSpecifier = {
                        oneofKind: "ads",
                        ads: AggregatedConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configSourceSpecifier as any).ads)
                    };
                    break;
                case /* envoy.config.core.v3.SelfConfigSource self */ 5:
                    message.configSourceSpecifier = {
                        oneofKind: "self",
                        self: SelfConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configSourceSpecifier as any).self)
                    };
                    break;
                case /* google.protobuf.Duration initial_fetch_timeout */ 4:
                    message.initialFetchTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.initialFetchTimeout);
                    break;
                case /* envoy.config.core.v3.ApiVersion resource_api_version */ 6:
                    message.resourceApiVersion = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xds.core.v3.Authority authorities = 7; */
        for (let i = 0; i < message.authorities.length; i++)
            Authority.internalBinaryWrite(message.authorities[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string path = 1 [deprecated = true]; */
        if (message.configSourceSpecifier.oneofKind === "path")
            writer.tag(1, WireType.LengthDelimited).string(message.configSourceSpecifier.path);
        /* envoy.config.core.v3.PathConfigSource path_config_source = 8; */
        if (message.configSourceSpecifier.oneofKind === "pathConfigSource")
            PathConfigSource.internalBinaryWrite(message.configSourceSpecifier.pathConfigSource, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ApiConfigSource api_config_source = 2; */
        if (message.configSourceSpecifier.oneofKind === "apiConfigSource")
            ApiConfigSource.internalBinaryWrite(message.configSourceSpecifier.apiConfigSource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.AggregatedConfigSource ads = 3; */
        if (message.configSourceSpecifier.oneofKind === "ads")
            AggregatedConfigSource.internalBinaryWrite(message.configSourceSpecifier.ads, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.SelfConfigSource self = 5; */
        if (message.configSourceSpecifier.oneofKind === "self")
            SelfConfigSource.internalBinaryWrite(message.configSourceSpecifier.self, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration initial_fetch_timeout = 4; */
        if (message.initialFetchTimeout)
            Duration.internalBinaryWrite(message.initialFetchTimeout, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ApiVersion resource_api_version = 6; */
        if (message.resourceApiVersion !== 0)
            writer.tag(6, WireType.Varint).int32(message.resourceApiVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.ConfigSource
 */
export const ConfigSource = new ConfigSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtensionConfigSource$Type extends MessageType<ExtensionConfigSource> {
    constructor() {
        super("envoy.config.core.v3.ExtensionConfigSource", [
            { no: 1, name: "config_source", kind: "message", T: () => ConfigSource, options: { "validate.rules": { any: { required: true } } } },
            { no: 2, name: "default_config", kind: "message", T: () => Any },
            { no: 3, name: "apply_default_config_without_warming", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "type_urls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<ExtensionConfigSource>): ExtensionConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.applyDefaultConfigWithoutWarming = false;
        message.typeUrls = [];
        if (value !== undefined)
            reflectionMergePartial<ExtensionConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtensionConfigSource): ExtensionConfigSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ConfigSource config_source */ 1:
                    message.configSource = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.configSource);
                    break;
                case /* google.protobuf.Any default_config */ 2:
                    message.defaultConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.defaultConfig);
                    break;
                case /* bool apply_default_config_without_warming */ 3:
                    message.applyDefaultConfigWithoutWarming = reader.bool();
                    break;
                case /* repeated string type_urls */ 4:
                    message.typeUrls.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtensionConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ConfigSource config_source = 1; */
        if (message.configSource)
            ConfigSource.internalBinaryWrite(message.configSource, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any default_config = 2; */
        if (message.defaultConfig)
            Any.internalBinaryWrite(message.defaultConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool apply_default_config_without_warming = 3; */
        if (message.applyDefaultConfigWithoutWarming !== false)
            writer.tag(3, WireType.Varint).bool(message.applyDefaultConfigWithoutWarming);
        /* repeated string type_urls = 4; */
        for (let i = 0; i < message.typeUrls.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.typeUrls[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.ExtensionConfigSource
 */
export const ExtensionConfigSource = new ExtensionConfigSource$Type();
