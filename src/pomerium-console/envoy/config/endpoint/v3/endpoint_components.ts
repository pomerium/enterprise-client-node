// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies
// @generated from protobuf file "envoy/config/endpoint/v3/endpoint_components.proto" (package "envoy.config.endpoint.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Locality } from "../../core/v3/base";
import { ConfigSource } from "../../core/v3/config_source";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Metadata } from "../../core/v3/base";
import { HealthStatus } from "../../core/v3/health_check";
import { Address } from "../../core/v3/address";
// [#protodoc-title: Endpoints]

/**
 * Upstream host identifier.
 *
 * @generated from protobuf message envoy.config.endpoint.v3.Endpoint
 */
export interface Endpoint {
    /**
     * The upstream host address.
     *
     * .. attention::
     *
     *   The form of host address depends on the given cluster type. For STATIC or EDS,
     *   it is expected to be a direct IP address (or something resolvable by the
     *   specified :ref:`resolver <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`
     *   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,
     *   and will be resolved via DNS.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address address = 1;
     */
    address?: Address;
    /**
     * The optional health check configuration is used as configuration for the
     * health checker to contact the health checked host.
     *
     * .. attention::
     *
     *   This takes into effect only for upstream clusters with
     *   :ref:`active health checking <arch_overview_health_checking>` enabled.
     *
     * @generated from protobuf field: envoy.config.endpoint.v3.Endpoint.HealthCheckConfig health_check_config = 2;
     */
    healthCheckConfig?: Endpoint_HealthCheckConfig;
    /**
     * The hostname associated with this endpoint. This hostname is not used for routing or address
     * resolution. If provided, it will be associated with the endpoint, and can be used for features
     * that require a hostname, like
     * :ref:`auto_host_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`.
     *
     * @generated from protobuf field: string hostname = 3;
     */
    hostname: string;
    /**
     * An ordered list of addresses that together with ``address`` comprise the
     * list of addresses for an endpoint. The address given in the ``address`` is
     * prepended to this list. It is assumed that the list must already be
     * sorted by preference order of the addresses. This will only be supported
     * for STATIC and EDS clusters.
     *
     * @generated from protobuf field: repeated envoy.config.endpoint.v3.Endpoint.AdditionalAddress additional_addresses = 4;
     */
    additionalAddresses: Endpoint_AdditionalAddress[];
}
/**
 * The optional health check configuration.
 *
 * @generated from protobuf message envoy.config.endpoint.v3.Endpoint.HealthCheckConfig
 */
export interface Endpoint_HealthCheckConfig {
    /**
     * Optional alternative health check port value.
     *
     * By default the health check address port of an upstream host is the same
     * as the host's serving address port. This provides an alternative health
     * check port. Setting this with a non-zero value allows an upstream host
     * to have different health check address port.
     *
     * @generated from protobuf field: uint32 port_value = 1;
     */
    portValue: number;
    /**
     * By default, the host header for L7 health checks is controlled by cluster level configuration
     * (see: :ref:`host <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.host>` and
     * :ref:`authority <envoy_v3_api_field_config.core.v3.HealthCheck.GrpcHealthCheck.authority>`). Setting this
     * to a non-empty value allows overriding the cluster level configuration for a specific
     * endpoint.
     *
     * @generated from protobuf field: string hostname = 2;
     */
    hostname: string;
    /**
     * Optional alternative health check host address.
     *
     * .. attention::
     *
     *   The form of the health check host address is expected to be a direct IP address.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address address = 3;
     */
    address?: Address;
    /**
     * Optional flag to control if perform active health check for this endpoint.
     * Active health check is enabled by default if there is a health checker.
     *
     * @generated from protobuf field: bool disable_active_health_check = 4;
     */
    disableActiveHealthCheck: boolean;
}
/**
 * @generated from protobuf message envoy.config.endpoint.v3.Endpoint.AdditionalAddress
 */
export interface Endpoint_AdditionalAddress {
    /**
     * Additional address that is associated with the endpoint.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address address = 1;
     */
    address?: Address;
}
/**
 * An Endpoint that Envoy can route traffic to.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.config.endpoint.v3.LbEndpoint
 */
export interface LbEndpoint {
    /**
     * @generated from protobuf oneof: host_identifier
     */
    hostIdentifier: {
        oneofKind: "endpoint";
        /**
         * @generated from protobuf field: envoy.config.endpoint.v3.Endpoint endpoint = 1;
         */
        endpoint: Endpoint;
    } | {
        oneofKind: "endpointName";
        /**
         * [#not-implemented-hide:]
         *
         * @generated from protobuf field: string endpoint_name = 5;
         */
        endpointName: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional health status when known and supplied by EDS server.
     *
     * @generated from protobuf field: envoy.config.core.v3.HealthStatus health_status = 2;
     */
    healthStatus: HealthStatus;
    /**
     * The endpoint metadata specifies values that may be used by the load
     * balancer to select endpoints in a cluster for a given request. The filter
     * name should be specified as ``envoy.lb``. An example boolean key-value pair
     * is ``canary``, providing the optional canary status of the upstream host.
     * This may be matched against in a route's
     * :ref:`RouteAction <envoy_v3_api_msg_config.route.v3.RouteAction>` metadata_match field
     * to subset the endpoints considered in cluster load balancing.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata = 3;
     */
    metadata?: Metadata;
    /**
     * The optional load balancing weight of the upstream host; at least 1.
     * Envoy uses the load balancing weight in some of the built in load
     * balancers. The load balancing weight for an endpoint is divided by the sum
     * of the weights of all endpoints in the endpoint's locality to produce a
     * percentage of traffic for the endpoint. This percentage is then further
     * weighted by the endpoint's locality's load balancing weight from
     * LocalityLbEndpoints. If unspecified, will be treated as 1. The sum
     * of the weights of all endpoints in the endpoint's locality must not
     * exceed uint32_t maximal value (4294967295).
     *
     * @generated from protobuf field: google.protobuf.UInt32Value load_balancing_weight = 4;
     */
    loadBalancingWeight?: UInt32Value;
}
/**
 * [#not-implemented-hide:]
 * A configuration for a LEDS collection.
 *
 * @generated from protobuf message envoy.config.endpoint.v3.LedsClusterLocalityConfig
 */
export interface LedsClusterLocalityConfig {
    /**
     * Configuration for the source of LEDS updates for a Locality.
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource leds_config = 1;
     */
    ledsConfig?: ConfigSource;
    /**
     * The xDS transport protocol glob collection resource name.
     * The service is only supported in delta xDS (incremental) mode.
     *
     * @generated from protobuf field: string leds_collection_name = 2;
     */
    ledsCollectionName: string;
}
/**
 * A group of endpoints belonging to a Locality.
 * One can have multiple LocalityLbEndpoints for a locality, but only if
 * they have different priorities.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.config.endpoint.v3.LocalityLbEndpoints
 */
export interface LocalityLbEndpoints {
    /**
     * Identifies location of where the upstream hosts run.
     *
     * @generated from protobuf field: envoy.config.core.v3.Locality locality = 1;
     */
    locality?: Locality;
    /**
     * The group of endpoints belonging to the locality specified.
     * [#comment:TODO(adisuissa): Once LEDS is implemented this field needs to be
     * deprecated and replaced by ``load_balancer_endpoints``.]
     *
     * @generated from protobuf field: repeated envoy.config.endpoint.v3.LbEndpoint lb_endpoints = 2;
     */
    lbEndpoints: LbEndpoint[];
    /**
     * @generated from protobuf oneof: lb_config
     */
    lbConfig: {
        oneofKind: "loadBalancerEndpoints";
        /**
         * The group of endpoints belonging to the locality.
         * [#comment:TODO(adisuissa): Once LEDS is implemented the ``lb_endpoints`` field
         * needs to be deprecated.]
         *
         * @generated from protobuf field: envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList load_balancer_endpoints = 7;
         */
        loadBalancerEndpoints: LocalityLbEndpoints_LbEndpointList;
    } | {
        oneofKind: "ledsClusterLocalityConfig";
        /**
         * LEDS Configuration for the current locality.
         *
         * @generated from protobuf field: envoy.config.endpoint.v3.LedsClusterLocalityConfig leds_cluster_locality_config = 8;
         */
        ledsClusterLocalityConfig: LedsClusterLocalityConfig;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
     * balancing weight for a locality is divided by the sum of the weights of all
     * localities  at the same priority level to produce the effective percentage
     * of traffic for the locality. The sum of the weights of all localities at
     * the same priority level must not exceed uint32_t maximal value (4294967295).
     *
     * Locality weights are only considered when :ref:`locality weighted load
     * balancing <arch_overview_load_balancing_locality_weighted_lb>` is
     * configured. These weights are ignored otherwise. If no weights are
     * specified when locality weighted load balancing is enabled, the locality is
     * assigned no load.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value load_balancing_weight = 3;
     */
    loadBalancingWeight?: UInt32Value;
    /**
     * Optional: the priority for this LocalityLbEndpoints. If unspecified this will
     * default to the highest priority (0).
     *
     * Under usual circumstances, Envoy will only select endpoints for the highest
     * priority (0). In the event that enough endpoints for a particular priority are
     * unavailable/unhealthy, Envoy will fail over to selecting endpoints for the
     * next highest priority group. Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>`.
     *
     * Priorities should range from 0 (highest) to N (lowest) without skipping.
     *
     * @generated from protobuf field: uint32 priority = 5;
     */
    priority: number;
    /**
     * Optional: Per locality proximity value which indicates how close this
     * locality is from the source locality. This value only provides ordering
     * information (lower the value, closer it is to the source locality).
     * This will be consumed by load balancing schemes that need proximity order
     * to determine where to route the requests.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value proximity = 6;
     */
    proximity?: UInt32Value;
}
/**
 * [#not-implemented-hide:]
 * A list of endpoints of a specific locality.
 *
 * @generated from protobuf message envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList
 */
export interface LocalityLbEndpoints_LbEndpointList {
    /**
     * @generated from protobuf field: repeated envoy.config.endpoint.v3.LbEndpoint lb_endpoints = 1;
     */
    lbEndpoints: LbEndpoint[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint$Type extends MessageType<Endpoint> {
    constructor() {
        super("envoy.config.endpoint.v3.Endpoint", [
            { no: 1, name: "address", kind: "message", T: () => Address },
            { no: 2, name: "health_check_config", kind: "message", T: () => Endpoint_HealthCheckConfig },
            { no: 3, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "additional_addresses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Endpoint_AdditionalAddress }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.endpoint.Endpoint" } });
    }
    create(value?: PartialMessage<Endpoint>): Endpoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostname = "";
        message.additionalAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<Endpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint): Endpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Address address */ 1:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* envoy.config.endpoint.v3.Endpoint.HealthCheckConfig health_check_config */ 2:
                    message.healthCheckConfig = Endpoint_HealthCheckConfig.internalBinaryRead(reader, reader.uint32(), options, message.healthCheckConfig);
                    break;
                case /* string hostname */ 3:
                    message.hostname = reader.string();
                    break;
                case /* repeated envoy.config.endpoint.v3.Endpoint.AdditionalAddress additional_addresses */ 4:
                    message.additionalAddresses.push(Endpoint_AdditionalAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Address address = 1; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.endpoint.v3.Endpoint.HealthCheckConfig health_check_config = 2; */
        if (message.healthCheckConfig)
            Endpoint_HealthCheckConfig.internalBinaryWrite(message.healthCheckConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string hostname = 3; */
        if (message.hostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostname);
        /* repeated envoy.config.endpoint.v3.Endpoint.AdditionalAddress additional_addresses = 4; */
        for (let i = 0; i < message.additionalAddresses.length; i++)
            Endpoint_AdditionalAddress.internalBinaryWrite(message.additionalAddresses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.endpoint.v3.Endpoint
 */
export const Endpoint = new Endpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint_HealthCheckConfig$Type extends MessageType<Endpoint_HealthCheckConfig> {
    constructor() {
        super("envoy.config.endpoint.v3.Endpoint.HealthCheckConfig", [
            { no: 1, name: "port_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 65535 } } } },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address", kind: "message", T: () => Address },
            { no: 4, name: "disable_active_health_check", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.endpoint.Endpoint.HealthCheckConfig" } });
    }
    create(value?: PartialMessage<Endpoint_HealthCheckConfig>): Endpoint_HealthCheckConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.portValue = 0;
        message.hostname = "";
        message.disableActiveHealthCheck = false;
        if (value !== undefined)
            reflectionMergePartial<Endpoint_HealthCheckConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint_HealthCheckConfig): Endpoint_HealthCheckConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 port_value */ 1:
                    message.portValue = reader.uint32();
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* envoy.config.core.v3.Address address */ 3:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* bool disable_active_health_check */ 4:
                    message.disableActiveHealthCheck = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint_HealthCheckConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 port_value = 1; */
        if (message.portValue !== 0)
            writer.tag(1, WireType.Varint).uint32(message.portValue);
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* envoy.config.core.v3.Address address = 3; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool disable_active_health_check = 4; */
        if (message.disableActiveHealthCheck !== false)
            writer.tag(4, WireType.Varint).bool(message.disableActiveHealthCheck);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.endpoint.v3.Endpoint.HealthCheckConfig
 */
export const Endpoint_HealthCheckConfig = new Endpoint_HealthCheckConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint_AdditionalAddress$Type extends MessageType<Endpoint_AdditionalAddress> {
    constructor() {
        super("envoy.config.endpoint.v3.Endpoint.AdditionalAddress", [
            { no: 1, name: "address", kind: "message", T: () => Address }
        ]);
    }
    create(value?: PartialMessage<Endpoint_AdditionalAddress>): Endpoint_AdditionalAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Endpoint_AdditionalAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint_AdditionalAddress): Endpoint_AdditionalAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Address address */ 1:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint_AdditionalAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Address address = 1; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.endpoint.v3.Endpoint.AdditionalAddress
 */
export const Endpoint_AdditionalAddress = new Endpoint_AdditionalAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LbEndpoint$Type extends MessageType<LbEndpoint> {
    constructor() {
        super("envoy.config.endpoint.v3.LbEndpoint", [
            { no: 1, name: "endpoint", kind: "message", oneof: "hostIdentifier", T: () => Endpoint },
            { no: 5, name: "endpoint_name", kind: "scalar", oneof: "hostIdentifier", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "health_status", kind: "enum", T: () => ["envoy.config.core.v3.HealthStatus", HealthStatus] },
            { no: 3, name: "metadata", kind: "message", T: () => Metadata },
            { no: 4, name: "load_balancing_weight", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.endpoint.LbEndpoint" } });
    }
    create(value?: PartialMessage<LbEndpoint>): LbEndpoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostIdentifier = { oneofKind: undefined };
        message.healthStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<LbEndpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LbEndpoint): LbEndpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.endpoint.v3.Endpoint endpoint */ 1:
                    message.hostIdentifier = {
                        oneofKind: "endpoint",
                        endpoint: Endpoint.internalBinaryRead(reader, reader.uint32(), options, (message.hostIdentifier as any).endpoint)
                    };
                    break;
                case /* string endpoint_name */ 5:
                    message.hostIdentifier = {
                        oneofKind: "endpointName",
                        endpointName: reader.string()
                    };
                    break;
                case /* envoy.config.core.v3.HealthStatus health_status */ 2:
                    message.healthStatus = reader.int32();
                    break;
                case /* envoy.config.core.v3.Metadata metadata */ 3:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* google.protobuf.UInt32Value load_balancing_weight */ 4:
                    message.loadBalancingWeight = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.loadBalancingWeight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LbEndpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.endpoint.v3.Endpoint endpoint = 1; */
        if (message.hostIdentifier.oneofKind === "endpoint")
            Endpoint.internalBinaryWrite(message.hostIdentifier.endpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string endpoint_name = 5; */
        if (message.hostIdentifier.oneofKind === "endpointName")
            writer.tag(5, WireType.LengthDelimited).string(message.hostIdentifier.endpointName);
        /* envoy.config.core.v3.HealthStatus health_status = 2; */
        if (message.healthStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.healthStatus);
        /* envoy.config.core.v3.Metadata metadata = 3; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value load_balancing_weight = 4; */
        if (message.loadBalancingWeight)
            UInt32Value.internalBinaryWrite(message.loadBalancingWeight, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.endpoint.v3.LbEndpoint
 */
export const LbEndpoint = new LbEndpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LedsClusterLocalityConfig$Type extends MessageType<LedsClusterLocalityConfig> {
    constructor() {
        super("envoy.config.endpoint.v3.LedsClusterLocalityConfig", [
            { no: 1, name: "leds_config", kind: "message", T: () => ConfigSource },
            { no: 2, name: "leds_collection_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LedsClusterLocalityConfig>): LedsClusterLocalityConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ledsCollectionName = "";
        if (value !== undefined)
            reflectionMergePartial<LedsClusterLocalityConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LedsClusterLocalityConfig): LedsClusterLocalityConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ConfigSource leds_config */ 1:
                    message.ledsConfig = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.ledsConfig);
                    break;
                case /* string leds_collection_name */ 2:
                    message.ledsCollectionName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LedsClusterLocalityConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ConfigSource leds_config = 1; */
        if (message.ledsConfig)
            ConfigSource.internalBinaryWrite(message.ledsConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string leds_collection_name = 2; */
        if (message.ledsCollectionName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ledsCollectionName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.endpoint.v3.LedsClusterLocalityConfig
 */
export const LedsClusterLocalityConfig = new LedsClusterLocalityConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalityLbEndpoints$Type extends MessageType<LocalityLbEndpoints> {
    constructor() {
        super("envoy.config.endpoint.v3.LocalityLbEndpoints", [
            { no: 1, name: "locality", kind: "message", T: () => Locality },
            { no: 2, name: "lb_endpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LbEndpoint },
            { no: 7, name: "load_balancer_endpoints", kind: "message", oneof: "lbConfig", T: () => LocalityLbEndpoints_LbEndpointList },
            { no: 8, name: "leds_cluster_locality_config", kind: "message", oneof: "lbConfig", T: () => LedsClusterLocalityConfig },
            { no: 3, name: "load_balancing_weight", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 5, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 128 } } } },
            { no: 6, name: "proximity", kind: "message", T: () => UInt32Value }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.endpoint.LocalityLbEndpoints" } });
    }
    create(value?: PartialMessage<LocalityLbEndpoints>): LocalityLbEndpoints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lbEndpoints = [];
        message.lbConfig = { oneofKind: undefined };
        message.priority = 0;
        if (value !== undefined)
            reflectionMergePartial<LocalityLbEndpoints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalityLbEndpoints): LocalityLbEndpoints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Locality locality */ 1:
                    message.locality = Locality.internalBinaryRead(reader, reader.uint32(), options, message.locality);
                    break;
                case /* repeated envoy.config.endpoint.v3.LbEndpoint lb_endpoints */ 2:
                    message.lbEndpoints.push(LbEndpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList load_balancer_endpoints */ 7:
                    message.lbConfig = {
                        oneofKind: "loadBalancerEndpoints",
                        loadBalancerEndpoints: LocalityLbEndpoints_LbEndpointList.internalBinaryRead(reader, reader.uint32(), options, (message.lbConfig as any).loadBalancerEndpoints)
                    };
                    break;
                case /* envoy.config.endpoint.v3.LedsClusterLocalityConfig leds_cluster_locality_config */ 8:
                    message.lbConfig = {
                        oneofKind: "ledsClusterLocalityConfig",
                        ledsClusterLocalityConfig: LedsClusterLocalityConfig.internalBinaryRead(reader, reader.uint32(), options, (message.lbConfig as any).ledsClusterLocalityConfig)
                    };
                    break;
                case /* google.protobuf.UInt32Value load_balancing_weight */ 3:
                    message.loadBalancingWeight = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.loadBalancingWeight);
                    break;
                case /* uint32 priority */ 5:
                    message.priority = reader.uint32();
                    break;
                case /* google.protobuf.UInt32Value proximity */ 6:
                    message.proximity = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.proximity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalityLbEndpoints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Locality locality = 1; */
        if (message.locality)
            Locality.internalBinaryWrite(message.locality, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.endpoint.v3.LbEndpoint lb_endpoints = 2; */
        for (let i = 0; i < message.lbEndpoints.length; i++)
            LbEndpoint.internalBinaryWrite(message.lbEndpoints[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList load_balancer_endpoints = 7; */
        if (message.lbConfig.oneofKind === "loadBalancerEndpoints")
            LocalityLbEndpoints_LbEndpointList.internalBinaryWrite(message.lbConfig.loadBalancerEndpoints, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.endpoint.v3.LedsClusterLocalityConfig leds_cluster_locality_config = 8; */
        if (message.lbConfig.oneofKind === "ledsClusterLocalityConfig")
            LedsClusterLocalityConfig.internalBinaryWrite(message.lbConfig.ledsClusterLocalityConfig, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value load_balancing_weight = 3; */
        if (message.loadBalancingWeight)
            UInt32Value.internalBinaryWrite(message.loadBalancingWeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 priority = 5; */
        if (message.priority !== 0)
            writer.tag(5, WireType.Varint).uint32(message.priority);
        /* google.protobuf.UInt32Value proximity = 6; */
        if (message.proximity)
            UInt32Value.internalBinaryWrite(message.proximity, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.endpoint.v3.LocalityLbEndpoints
 */
export const LocalityLbEndpoints = new LocalityLbEndpoints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalityLbEndpoints_LbEndpointList$Type extends MessageType<LocalityLbEndpoints_LbEndpointList> {
    constructor() {
        super("envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList", [
            { no: 1, name: "lb_endpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LbEndpoint }
        ]);
    }
    create(value?: PartialMessage<LocalityLbEndpoints_LbEndpointList>): LocalityLbEndpoints_LbEndpointList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lbEndpoints = [];
        if (value !== undefined)
            reflectionMergePartial<LocalityLbEndpoints_LbEndpointList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalityLbEndpoints_LbEndpointList): LocalityLbEndpoints_LbEndpointList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.endpoint.v3.LbEndpoint lb_endpoints */ 1:
                    message.lbEndpoints.push(LbEndpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalityLbEndpoints_LbEndpointList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.endpoint.v3.LbEndpoint lb_endpoints = 1; */
        for (let i = 0; i < message.lbEndpoints.length; i++)
            LbEndpoint.internalBinaryWrite(message.lbEndpoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList
 */
export const LocalityLbEndpoints_LbEndpointList = new LocalityLbEndpoints_LbEndpointList$Type();
