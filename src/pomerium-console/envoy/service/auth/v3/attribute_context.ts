// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies
// @generated from protobuf file "envoy/service/auth/v3/attribute_context.proto" (package "envoy.service.auth.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../../google/protobuf/timestamp";
import { Address } from "../../../config/core/v3/address";
import { Metadata } from "../../../config/core/v3/base";
// [#protodoc-title: Attribute context]

// See :ref:`network filter configuration overview <config_network_filters_ext_authz>`
// and :ref:`HTTP filter configuration overview <config_http_filters_ext_authz>`.

/**
 * An attribute is a piece of metadata that describes an activity on a network.
 * For example, the size of an HTTP request, or the status code of an HTTP response.
 *
 * Each attribute has a type and a name, which is logically defined as a proto message field
 * of the ``AttributeContext``. The ``AttributeContext`` is a collection of individual attributes
 * supported by Envoy authorization system.
 * [#comment: The following items are left out of this proto
 * Request.Auth field for jwt tokens
 * Request.Api for api management
 * Origin peer that originated the request
 * Caching Protocol
 * request_context return values to inject back into the filter chain
 * peer.claims -- from X.509 extensions
 * Configuration
 * - field mask to send
 * - which return values from request_context are copied back
 * - which return values are copied into request_headers]
 * [#next-free-field: 13]
 *
 * @generated from protobuf message envoy.service.auth.v3.AttributeContext
 */
export interface AttributeContext {
    /**
     * The source of a network activity, such as starting a TCP connection.
     * In a multi hop network activity, the source represents the sender of the
     * last hop.
     *
     * @generated from protobuf field: envoy.service.auth.v3.AttributeContext.Peer source = 1;
     */
    source?: AttributeContext_Peer;
    /**
     * The destination of a network activity, such as accepting a TCP connection.
     * In a multi hop network activity, the destination represents the receiver of
     * the last hop.
     *
     * @generated from protobuf field: envoy.service.auth.v3.AttributeContext.Peer destination = 2;
     */
    destination?: AttributeContext_Peer;
    /**
     * Represents a network request, such as an HTTP request.
     *
     * @generated from protobuf field: envoy.service.auth.v3.AttributeContext.Request request = 4;
     */
    request?: AttributeContext_Request;
    /**
     * This is analogous to http_request.headers, however these contents will not be sent to the
     * upstream server. Context_extensions provide an extension mechanism for sending additional
     * information to the auth server without modifying the proto definition. It maps to the
     * internal opaque context in the filter chain.
     *
     * @generated from protobuf field: map<string, string> context_extensions = 10;
     */
    contextExtensions: {
        [key: string]: string;
    };
    /**
     * Dynamic metadata associated with the request.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata_context = 11;
     */
    metadataContext?: Metadata;
    /**
     * TLS session details of the underlying connection.
     * This is not populated by default and will be populated if ext_authz filter's
     * :ref:`include_tls_session <config_http_filters_ext_authz>` is set to true.
     *
     * @generated from protobuf field: envoy.service.auth.v3.AttributeContext.TLSSession tls_session = 12;
     */
    tlsSession?: AttributeContext_TLSSession;
}
/**
 * This message defines attributes for a node that handles a network request.
 * The node can be either a service or an application that sends, forwards,
 * or receives the request. Service peers should fill in the ``service``,
 * ``principal``, and ``labels`` as appropriate.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.service.auth.v3.AttributeContext.Peer
 */
export interface AttributeContext_Peer {
    /**
     * The address of the peer, this is typically the IP address.
     * It can also be UDS path, or others.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address address = 1;
     */
    address?: Address;
    /**
     * The canonical service name of the peer.
     * It should be set to :ref:`the HTTP x-envoy-downstream-service-cluster
     * <config_http_conn_man_headers_downstream-service-cluster>`
     * If a more trusted source of the service name is available through mTLS/secure naming, it
     * should be used.
     *
     * @generated from protobuf field: string service = 2;
     */
    service: string;
    /**
     * The labels associated with the peer.
     * These could be pod labels for Kubernetes or tags for VMs.
     * The source of the labels could be an X.509 certificate or other configuration.
     *
     * @generated from protobuf field: map<string, string> labels = 3;
     */
    labels: {
        [key: string]: string;
    };
    /**
     * The authenticated identity of this peer.
     * For example, the identity associated with the workload such as a service account.
     * If an X.509 certificate is used to assert the identity this field should be sourced from
     * ``URI Subject Alternative Names``, ``DNS Subject Alternate Names`` or ``Subject`` in that order.
     * The primary identity should be the principal. The principal format is issuer specific.
     *
     * Examples:
     *
     * - SPIFFE format is ``spiffe://trust-domain/path``.
     * - Google account format is ``https://accounts.google.com/{userid}``.
     *
     * @generated from protobuf field: string principal = 4;
     */
    principal: string;
    /**
     * The X.509 certificate used to authenticate the identify of this peer.
     * When present, the certificate contents are encoded in URL and PEM format.
     *
     * @generated from protobuf field: string certificate = 5;
     */
    certificate: string;
}
/**
 * Represents a network request, such as an HTTP request.
 *
 * @generated from protobuf message envoy.service.auth.v3.AttributeContext.Request
 */
export interface AttributeContext_Request {
    /**
     * The timestamp when the proxy receives the first byte of the request.
     *
     * @generated from protobuf field: google.protobuf.Timestamp time = 1;
     */
    time?: Timestamp;
    /**
     * Represents an HTTP request or an HTTP-like request.
     *
     * @generated from protobuf field: envoy.service.auth.v3.AttributeContext.HttpRequest http = 2;
     */
    http?: AttributeContext_HttpRequest;
}
/**
 * This message defines attributes for an HTTP request.
 * HTTP/1.x, HTTP/2, gRPC are all considered as HTTP requests.
 * [#next-free-field: 13]
 *
 * @generated from protobuf message envoy.service.auth.v3.AttributeContext.HttpRequest
 */
export interface AttributeContext_HttpRequest {
    /**
     * The unique ID for a request, which can be propagated to downstream
     * systems. The ID should have low probability of collision
     * within a single day for a specific service.
     * For HTTP requests, it should be X-Request-ID or equivalent.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The HTTP request method, such as ``GET``, ``POST``.
     *
     * @generated from protobuf field: string method = 2;
     */
    method: string;
    /**
     * The HTTP request headers. If multiple headers share the same key, they
     * must be merged according to the HTTP spec. All header keys must be
     * lower-cased, because HTTP header keys are case-insensitive.
     *
     * @generated from protobuf field: map<string, string> headers = 3;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * The request target, as it appears in the first line of the HTTP request. This includes
     * the URL path and query-string. No decoding is performed.
     *
     * @generated from protobuf field: string path = 4;
     */
    path: string;
    /**
     * The HTTP request ``Host`` or ``:authority`` header value.
     *
     * @generated from protobuf field: string host = 5;
     */
    host: string;
    /**
     * The HTTP URL scheme, such as ``http`` and ``https``.
     *
     * @generated from protobuf field: string scheme = 6;
     */
    scheme: string;
    /**
     * This field is always empty, and exists for compatibility reasons. The HTTP URL query is
     * included in ``path`` field.
     *
     * @generated from protobuf field: string query = 7;
     */
    query: string;
    /**
     * This field is always empty, and exists for compatibility reasons. The URL fragment is
     * not submitted as part of HTTP requests; it is unknowable.
     *
     * @generated from protobuf field: string fragment = 8;
     */
    fragment: string;
    /**
     * The HTTP request size in bytes. If unknown, it must be -1.
     *
     * @generated from protobuf field: int64 size = 9;
     */
    size: bigint;
    /**
     * The network protocol used with the request, such as "HTTP/1.0", "HTTP/1.1", or "HTTP/2".
     *
     * See :repo:`headers.h:ProtocolStrings <source/common/http/headers.h>` for a list of all
     * possible values.
     *
     * @generated from protobuf field: string protocol = 10;
     */
    protocol: string;
    /**
     * The HTTP request body.
     *
     * @generated from protobuf field: string body = 11;
     */
    body: string;
    /**
     * The HTTP request body in bytes. This is used instead of
     * :ref:`body <envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.body>` when
     * :ref:`pack_as_bytes <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.BufferSettings.pack_as_bytes>`
     * is set to true.
     *
     * @generated from protobuf field: bytes raw_body = 12;
     */
    rawBody: Uint8Array;
}
/**
 * This message defines attributes for the underlying TLS session.
 *
 * @generated from protobuf message envoy.service.auth.v3.AttributeContext.TLSSession
 */
export interface AttributeContext_TLSSession {
    /**
     * SNI used for TLS session.
     *
     * @generated from protobuf field: string sni = 1;
     */
    sni: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext$Type extends MessageType<AttributeContext> {
    constructor() {
        super("envoy.service.auth.v3.AttributeContext", [
            { no: 1, name: "source", kind: "message", T: () => AttributeContext_Peer },
            { no: 2, name: "destination", kind: "message", T: () => AttributeContext_Peer },
            { no: 4, name: "request", kind: "message", T: () => AttributeContext_Request },
            { no: 10, name: "context_extensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 11, name: "metadata_context", kind: "message", T: () => Metadata },
            { no: 12, name: "tls_session", kind: "message", T: () => AttributeContext_TLSSession }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.auth.v2.AttributeContext" } });
    }
    create(value?: PartialMessage<AttributeContext>): AttributeContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contextExtensions = {};
        if (value !== undefined)
            reflectionMergePartial<AttributeContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext): AttributeContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.auth.v3.AttributeContext.Peer source */ 1:
                    message.source = AttributeContext_Peer.internalBinaryRead(reader, reader.uint32(), options, message.source);
                    break;
                case /* envoy.service.auth.v3.AttributeContext.Peer destination */ 2:
                    message.destination = AttributeContext_Peer.internalBinaryRead(reader, reader.uint32(), options, message.destination);
                    break;
                case /* envoy.service.auth.v3.AttributeContext.Request request */ 4:
                    message.request = AttributeContext_Request.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* map<string, string> context_extensions */ 10:
                    this.binaryReadMap10(message.contextExtensions, reader, options);
                    break;
                case /* envoy.config.core.v3.Metadata metadata_context */ 11:
                    message.metadataContext = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadataContext);
                    break;
                case /* envoy.service.auth.v3.AttributeContext.TLSSession tls_session */ 12:
                    message.tlsSession = AttributeContext_TLSSession.internalBinaryRead(reader, reader.uint32(), options, message.tlsSession);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: AttributeContext["contextExtensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AttributeContext["contextExtensions"] | undefined, val: AttributeContext["contextExtensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.service.auth.v3.AttributeContext.context_extensions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AttributeContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.auth.v3.AttributeContext.Peer source = 1; */
        if (message.source)
            AttributeContext_Peer.internalBinaryWrite(message.source, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.auth.v3.AttributeContext.Peer destination = 2; */
        if (message.destination)
            AttributeContext_Peer.internalBinaryWrite(message.destination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.auth.v3.AttributeContext.Request request = 4; */
        if (message.request)
            AttributeContext_Request.internalBinaryWrite(message.request, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> context_extensions = 10; */
        for (let k of globalThis.Object.keys(message.contextExtensions))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.contextExtensions[k]).join();
        /* envoy.config.core.v3.Metadata metadata_context = 11; */
        if (message.metadataContext)
            Metadata.internalBinaryWrite(message.metadataContext, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.auth.v3.AttributeContext.TLSSession tls_session = 12; */
        if (message.tlsSession)
            AttributeContext_TLSSession.internalBinaryWrite(message.tlsSession, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.auth.v3.AttributeContext
 */
export const AttributeContext = new AttributeContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_Peer$Type extends MessageType<AttributeContext_Peer> {
    constructor() {
        super("envoy.service.auth.v3.AttributeContext.Peer", [
            { no: 1, name: "address", kind: "message", T: () => Address },
            { no: 2, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "principal", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "certificate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.auth.v2.AttributeContext.Peer" } });
    }
    create(value?: PartialMessage<AttributeContext_Peer>): AttributeContext_Peer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.service = "";
        message.labels = {};
        message.principal = "";
        message.certificate = "";
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_Peer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_Peer): AttributeContext_Peer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Address address */ 1:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* string service */ 2:
                    message.service = reader.string();
                    break;
                case /* map<string, string> labels */ 3:
                    this.binaryReadMap3(message.labels, reader, options);
                    break;
                case /* string principal */ 4:
                    message.principal = reader.string();
                    break;
                case /* string certificate */ 5:
                    message.certificate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: AttributeContext_Peer["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AttributeContext_Peer["labels"] | undefined, val: AttributeContext_Peer["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.service.auth.v3.AttributeContext.Peer.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AttributeContext_Peer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Address address = 1; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string service = 2; */
        if (message.service !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.service);
        /* map<string, string> labels = 3; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* string principal = 4; */
        if (message.principal !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.principal);
        /* string certificate = 5; */
        if (message.certificate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.certificate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.auth.v3.AttributeContext.Peer
 */
export const AttributeContext_Peer = new AttributeContext_Peer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_Request$Type extends MessageType<AttributeContext_Request> {
    constructor() {
        super("envoy.service.auth.v3.AttributeContext.Request", [
            { no: 1, name: "time", kind: "message", T: () => Timestamp },
            { no: 2, name: "http", kind: "message", T: () => AttributeContext_HttpRequest }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.auth.v2.AttributeContext.Request" } });
    }
    create(value?: PartialMessage<AttributeContext_Request>): AttributeContext_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_Request): AttributeContext_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp time */ 1:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* envoy.service.auth.v3.AttributeContext.HttpRequest http */ 2:
                    message.http = AttributeContext_HttpRequest.internalBinaryRead(reader, reader.uint32(), options, message.http);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeContext_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp time = 1; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.auth.v3.AttributeContext.HttpRequest http = 2; */
        if (message.http)
            AttributeContext_HttpRequest.internalBinaryWrite(message.http, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.auth.v3.AttributeContext.Request
 */
export const AttributeContext_Request = new AttributeContext_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_HttpRequest$Type extends MessageType<AttributeContext_HttpRequest> {
    constructor() {
        super("envoy.service.auth.v3.AttributeContext.HttpRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "scheme", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "fragment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "protocol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "body", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "raw_body", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.auth.v2.AttributeContext.HttpRequest" } });
    }
    create(value?: PartialMessage<AttributeContext_HttpRequest>): AttributeContext_HttpRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.method = "";
        message.headers = {};
        message.path = "";
        message.host = "";
        message.scheme = "";
        message.query = "";
        message.fragment = "";
        message.size = 0n;
        message.protocol = "";
        message.body = "";
        message.rawBody = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_HttpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_HttpRequest): AttributeContext_HttpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string method */ 2:
                    message.method = reader.string();
                    break;
                case /* map<string, string> headers */ 3:
                    this.binaryReadMap3(message.headers, reader, options);
                    break;
                case /* string path */ 4:
                    message.path = reader.string();
                    break;
                case /* string host */ 5:
                    message.host = reader.string();
                    break;
                case /* string scheme */ 6:
                    message.scheme = reader.string();
                    break;
                case /* string query */ 7:
                    message.query = reader.string();
                    break;
                case /* string fragment */ 8:
                    message.fragment = reader.string();
                    break;
                case /* int64 size */ 9:
                    message.size = reader.int64().toBigInt();
                    break;
                case /* string protocol */ 10:
                    message.protocol = reader.string();
                    break;
                case /* string body */ 11:
                    message.body = reader.string();
                    break;
                case /* bytes raw_body */ 12:
                    message.rawBody = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: AttributeContext_HttpRequest["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AttributeContext_HttpRequest["headers"] | undefined, val: AttributeContext_HttpRequest["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.service.auth.v3.AttributeContext.HttpRequest.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AttributeContext_HttpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string method = 2; */
        if (message.method !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.method);
        /* map<string, string> headers = 3; */
        for (let k of globalThis.Object.keys(message.headers))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* string path = 4; */
        if (message.path !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.path);
        /* string host = 5; */
        if (message.host !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.host);
        /* string scheme = 6; */
        if (message.scheme !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.scheme);
        /* string query = 7; */
        if (message.query !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.query);
        /* string fragment = 8; */
        if (message.fragment !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.fragment);
        /* int64 size = 9; */
        if (message.size !== 0n)
            writer.tag(9, WireType.Varint).int64(message.size);
        /* string protocol = 10; */
        if (message.protocol !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.protocol);
        /* string body = 11; */
        if (message.body !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.body);
        /* bytes raw_body = 12; */
        if (message.rawBody.length)
            writer.tag(12, WireType.LengthDelimited).bytes(message.rawBody);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.auth.v3.AttributeContext.HttpRequest
 */
export const AttributeContext_HttpRequest = new AttributeContext_HttpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeContext_TLSSession$Type extends MessageType<AttributeContext_TLSSession> {
    constructor() {
        super("envoy.service.auth.v3.AttributeContext.TLSSession", [
            { no: 1, name: "sni", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttributeContext_TLSSession>): AttributeContext_TLSSession {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sni = "";
        if (value !== undefined)
            reflectionMergePartial<AttributeContext_TLSSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeContext_TLSSession): AttributeContext_TLSSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sni */ 1:
                    message.sni = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeContext_TLSSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sni = 1; */
        if (message.sni !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sni);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.auth.v3.AttributeContext.TLSSession
 */
export const AttributeContext_TLSSession = new AttributeContext_TLSSession$Type();
